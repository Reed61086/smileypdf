<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PDF Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/signature_pad/1.5.3/signature_pad.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5',
                        secondary: '#6B7280',
                        accent: '#10B981',
                        danger: '#EF4444',
                    }
                }
            }
        }
    </script>
    <style>
        #pdf-render {
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin: 0 auto;
            position: relative;
            overflow: hidden; /* Keep hidden for container, annotation overflow should be handled */
        }
        .canvas-container {
            position: relative;
            margin: 0 auto;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .annotation {
            position: absolute;
            cursor: move;
            resize: both;
            overflow: visible; /* Changed from hidden/removed - allow text overflow */
            min-width: 50px;
            min-height: 20px;
            border: 1px dashed transparent;
            z-index: 5; /* Ensure annotations are above the canvas */
        }
        .annotation:hover {
            border-color: #4F46E5;
        }
        .annotation.selected {
            border: 1px dashed #4F46E5;
            background-color: rgba(79, 70, 229, 0.1);
        }
        .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px; /* Increased size slightly */
            height: 24px; /* Increased size slightly */
            background-color: #EF4444;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .annotation:hover .delete-btn {
            opacity: 1;
        }
        #signature-pad {
            border: 1px solid #e5e7eb;
            background-color: white;
            touch-action: none;
            width: 100%;
        }
        .tool-panel {
            position: absolute;
            left: 70px;
            top: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 10px;
            z-index: 100;
            width: 250px;
            display: none;
        }
        .color-option {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            margin: 3px;
            border: 2px solid white;
        }
        .color-option.selected {
            border-color: #4F46E5;
            transform: scale(1.1);
        }
        .font-option {
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        .font-option.selected {
            background-color: #E5E7EB;
            font-weight: bold;
        }
        .tooltip-text {
            position: absolute;
            left: 60px;
            background-color: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            white-space: nowrap;
            z-index: 1000;
        }
        .group:hover .tooltip-text {
            opacity: 1;
        }
        #signature-type-container {
            margin-top: 10px;
        }
        #file-input {
            display: none;
        }
        #initials-text {
            display: none;
        }
        .active-tool {
            background-color: #4F46E5 !important;
            color: white !important;
        }
        /* Resize handle styling */
        .annotation::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: #4F46E5;
            border-radius: 2px;
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .annotation:hover::after {
            opacity: 1;
        }
        /* Editable text area */
        .editable-text {
            min-height: 20px; /* Ensure it's at least clickable */
            width: 100%; /* Take full width of parent */
            height: 100%; /* Take full height of parent */
            outline: none;
            padding: 2px;
            cursor: text;
            box-sizing: border-box; /* Include padding in size */
            overflow-wrap: break-word; /* Allow long words to break */
            word-wrap: break-word; /* Older browser support */
            white-space: pre-wrap; /* Preserve whitespace and wrap */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="flex h-screen overflow-hidden">
        <!-- Left Toolbar -->
        <div class="w-16 bg-white shadow-md flex flex-col items-center py-4 space-y-6">
            <!-- Upload PDF Button -->
            <div class="group relative">
                <button id="upload-btn" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-file-upload text-gray-700"></i>
                </button>
                <input type="file" id="file-input" accept=".pdf">
                <span class="tooltip-text">Upload PDF</span>
            </div>

            <!-- Text Tool -->
            <div class="group relative">
                <button id="text-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-font text-gray-700"></i>
                </button>
                <span class="tooltip-text">Text Tool</span>
            </div>

            <!-- Signature Tool -->
            <div class="group relative">
                <button id="signature-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-signature text-gray-700"></i>
                </button>
                <span class="tooltip-text">Signature/Initials</span>
            </div>

            <!-- Image Tool -->
            <div class="group relative">
                <button id="image-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-image text-gray-700"></i>
                </button>
                <span class="tooltip-text">Image Tool</span>
            </div>

            <!-- Highlight Tool -->
            <div class="group relative">
                <button id="highlight-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-highlighter text-gray-700"></i>
                </button>
                <span class="tooltip-text">Highlight Tool</span>
            </div>

            <!-- Save Button -->
            <div class="group relative mt-auto">
                <button id="save-pdf" class="w-12 h-12 rounded-lg flex items-center justify-center bg-primary hover:bg-purple-700 transition text-white">
                    <i class="fas fa-save"></i>
                </button>
                <span class="tooltip-text">Save PDF</span>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Top Bar -->
            <div class="bg-white shadow-sm py-3 px-4 flex items-center justify-between">
                <h1 class="text-xl font-semibold text-gray-800">PDF Editor</h1>
                <div class="flex items-center space-x-4">
                    <div>
                        <span class="text-gray-600 mr-2">Page:</span>
                        <select id="page-select" class="border rounded px-2 py-1">
                            <!-- Pages will be added dynamically -->
                        </select>
                    </div>
                    <button id="zoom-in" class="w-8 h-8 rounded flex items-center justify-center hover:bg-gray-100">
                        <i class="fas fa-search-plus text-gray-600"></i>
                    </button>
                    <button id="zoom-out" class="w-8 h-8 rounded flex items-center justify-center hover:bg-gray-100">
                        <i class="fas fa-search-minus text-gray-600"></i>
                    </button>
                </div>
            </div>

            <!-- PDF Viewer -->
            <div class="flex-1 overflow-auto p-6 bg-gray-50" id="pdf-viewer">
                <div id="pdf-container" class="relative mx-auto">
                    <div id="pdf-render" class="canvas-container">
                        <canvas id="pdf-canvas"></canvas>
                        <!-- Annotations will be added here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Text Tool Panel -->
        <div id="text-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Text Properties</h3>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Font Family</label>
                <div class="flex flex-wrap">
                    <div class="font-option selected" style="font-family: 'Arial'">Arial</div>
                    <div class="font-option" style="font-family: 'Times New Roman'">Times</div>
                    <div class="font-option" style="font-family: 'Courier New'">Courier</div>
                    <div class="font-option" style="font-family: 'Georgia'">Georgia</div>
                    <div class="font-option" style="font-family: 'Verdana'">Verdana</div>
                    <div class="font-option" style="font-family: 'Comic Sans MS'">Comic</div>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Font Size</label>
                <input type="range" id="text-size" min="8" max="72" value="14" class="w-full">
                <div class="flex justify-between text-xs text-gray-600">
                    <span>8</span>
                    <span>20</span>
                    <span>32</span>
                    <span>44</span>
                    <span>56</span>
                    <span>72</span>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Text Color</label>
                <div class="flex flex-wrap">
                    <div class="color-option bg-black selected" data-color="black"></div>
                    <div class="color-option bg-red-500" data-color="red"></div>
                    <div class="color-option bg-blue-500" data-color="blue"></div>
                    <div class="color-option bg-green-500" data-color="green"></div>
                    <div class="color-option bg-yellow-500" data-color="yellow"></div>
                    <div class="color-option bg-purple-500" data-color="purple"></div>
                    <div class="color-option bg-pink-500" data-color="pink"></div>
                    <div class="color-option bg-gray-500" data-color="gray"></div>
                </div>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Bold/Italic/Underline</label>
                <div class="flex">
                    <button id="bold-text" class="px-3 py-1 border rounded-l hover:bg-gray-100">
                        <i class="fas fa-bold"></i>
                    </button>
                    <button id="italic-text" class="px-3 py-1 border-t border-b hover:bg-gray-100">
                        <i class="fas fa-italic"></i>
                    </button>
                    <button id="underline-text" class="px-3 py-1 border rounded-r hover:bg-gray-100">
                        <i class="fas fa-underline"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Signature Tool Panel -->
        <div id="signature-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Add Signature/Initials</h3>
            <div class="mb-4">
                <div class="flex space-x-3 mb-3">
                    <button id="draw-signature" class="flex-1 py-2 bg-primary text-white rounded hover:bg-purple-700">Draw</button>
                    <button id="type-signature" class="flex-1 py-2 bg-gray-100 rounded hover:bg-gray-200">Type</button>
                    <button id="initials-btn" class="flex-1 py-2 bg-gray-100 rounded hover:bg-gray-200">Initials</button>
                </div>
                <div id="signature-draw-container" class="border rounded mb-3">
                    <div class="flex justify-between items-center mb-2 px-2 pt-1">
                        <label class="text-sm font-medium text-gray-700">Pen Color:</label>
                        <div class="flex">
                            <div class="color-option bg-black selected" data-color="black" onclick="setSignatureColor('black')"></div>
                            <div class="color-option bg-red-500" data-color="red" onclick="setSignatureColor('red')"></div>
                            <div class="color-option bg-blue-500" data-color="blue" onclick="setSignatureColor('blue')"></div>
                            <div class="color-option bg-green-500" data-color="green" onclick="setSignatureColor('green')"></div>
                        </div>
                    </div>
                    <canvas id="signature-pad" height="150"></canvas>
                </div>
                <div id="signature-type-container" class="mb-3 hidden">
                    <input type="text" id="signature-text" placeholder="Type your name" class="w-full border rounded px-3 py-2">
                    <input type="text" id="initials-text" placeholder="Type your initials" class="w-full border rounded px-3 py-2 mt-2 hidden">
                    <div class="flex mt-2 items-center">
                        <select id="signature-font" class="border rounded px-2 py-1 flex-1 mr-2">
                            <option value="'Brush Script MT', cursive">Brush Script</option>
                            <option value="'Dancing Script', cursive">Dancing Script</option>
                            <option value="'Parisienne', cursive">Parisienne</option>
                            <option value="'Great Vibes', cursive">Great Vibes</option>
                        </select>
                        <div class="flex">
                            <div class="color-option bg-black selected" data-color="black" onclick="setTypedSignatureColor('black')"></div>
                            <div class="color-option bg-red-500" data-color="red" onclick="setTypedSignatureColor('red')"></div>
                            <div class="color-option bg-blue-500" data-color="blue" onclick="setTypedSignatureColor('blue')"></div>
                            <div class="color-option bg-green-500" data-color="green" onclick="setTypedSignatureColor('green')"></div>
                            <div class="color-option bg-purple-500" data-color="purple" onclick="setTypedSignatureColor('purple')"></div>
                        </div>
                    </div>
                </div>
                <div class="flex justify-between">
                    <button id="clear-signature" class="px-3 py-2 bg-gray-200 rounded hover:bg-gray-300">
                        Clear
                    </button>
                    <button id="save-signature" class="px-3 py-2 bg-primary text-white rounded hover:bg-purple-700">
                        Save & Add
                    </button>
                </div>
            </div>
        </div>

        <!-- Image Tool Panel -->
        <div id="image-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Add Image</h3>
            <div class="mb-4">
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center">
                    <i class="fas fa-image text-4xl text-gray-400 mb-2"></i>
                    <p class="text-sm text-gray-500">Drag & drop image here or</p>
                    <button id="browse-images" class="mt-2 px-4 py-2 bg-primary text-white rounded hover:bg-purple-700">
                        Browse Files
                    </button>
                    <input type="file" id="image-input" accept="image/*" class="hidden">
                </div>
            </div>
        </div>

        <!-- Highlight Tool Panel -->
        <div id="highlight-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Highlight Properties</h3>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Highlight Color</label>
                <div class="flex flex-wrap">
                    <!-- Updated highlight colors to match Tailwind better -->
                    <div class="color-option selected" data-color="yellow" style="background-color: rgba(253, 224, 71, 0.5);"></div>
                    <div class="color-option" data-color="green" style="background-color: rgba(75, 181, 67, 0.5);"></div>
                    <div class="color-option" data-color="blue" style="background-color: rgba(59, 130, 246, 0.5);"></div>
                    <div class="color-option" data-color="pink" style="background-color: rgba(236, 72, 153, 0.5);"></div>
                    <div class="color-option" data-color="purple" style="background-color: rgba(139, 92, 246, 0.5);"></div>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Opacity</label>
                <input type="range" id="highlight-opacity" min="30" max="100" value="50" class="w-full">
                <div class="flex justify-between text-xs text-gray-600">
                    <span>30%</span>
                    <span>65%</span>
                    <span>100%</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // PDF.js setup
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        // Global variables
        const colorMap = { // For saving/mapping non-standard colors if needed later
            black: '#000000', red: '#EF4444', blue: '#3B82F6', green: '#10B981',
            yellow: '#F59E0B', purple: '#8B5CF6', pink: '#EC4899', gray: '#6B7280'
        };
        const highlightColorMap = {
             yellow: 'rgba(253, 224, 71, ##OPACITY##)', // yellow-400
             green: 'rgba(75, 181, 67, ##OPACITY##)',  // green-500 approx
             blue: 'rgba(59, 130, 246, ##OPACITY##)',   // blue-500
             pink: 'rgba(236, 72, 153, ##OPACITY##)',   // pink-500
             purple: 'rgba(139, 92, 246, ##OPACITY##)'  // purple-500
         };

        let pdfDoc = null,
            pageNum = 1,
            pageRendering = false,
            pageNumPending = null,
            scale = 1.0,
            canvas = document.getElementById('pdf-canvas'),
            ctx = canvas.getContext('2d'),
            activeTool = null,
            annotations = [], // Stores { id, type, page, x, y, width, height, properties, content, signatureType? }
            selectedAnnotation = null, // Stores the DOM element
            signaturePad = null,
            currentSignatureColor = 'black', // For drawing pad
            currentTypedSignatureColor = 'black', // For typed text
            currentTextProperties = {
                fontFamily: 'Arial',
                fontSize: 14,
                color: 'black', // Use standard CSS color names/hex here
                bold: false,
                italic: false,
                underline: false
            },
            currentHighlightProperties = {
                color: 'yellow', // Corresponds to keys in highlightColorMap
                opacity: 0.5
            };

        // Initialize the editor
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();

            const signatureCanvas = document.getElementById('signature-pad');
            signaturePad = new SignaturePad(signatureCanvas, {
                backgroundColor: 'rgba(255, 255, 255, 0)',
                penColor: colorMap[currentSignatureColor], // Use map for initial color
            });

            window.addEventListener('resize', resizeSignatureCanvas);
            resizeSignatureCanvas();
            renderBlankCanvas();
        });

        function resizeSignatureCanvas() {
            const canvas = document.getElementById('signature-pad');
            const ratio = Math.max(window.devicePixelRatio || 1, 1);
            canvas.width = canvas.offsetWidth * ratio;
            canvas.height = canvas.offsetHeight * ratio;
            canvas.getContext('2d').scale(ratio, ratio);
            if (signaturePad) {
                signaturePad.clear();
            }
        }

        function setupEventListeners() {
            // --- Toolbar Buttons ---
            document.getElementById('upload-btn').addEventListener('click', () => document.getElementById('file-input').click());
            document.getElementById('file-input').addEventListener('change', handleFileSelect);

            document.getElementById('text-tool').addEventListener('click', function() {
                toggleTool('text', 'text-tool-panel');
            });
            document.getElementById('signature-tool').addEventListener('click', function() {
                toggleTool('signature', 'signature-tool-panel');
                if (activeTool === 'signature') { // Reset signature panel state
                    document.getElementById('signature-draw-container').classList.remove('hidden');
                    document.getElementById('signature-type-container').classList.add('hidden');
                    document.getElementById('initials-text').classList.add('hidden');
                    document.getElementById('signature-text').classList.remove('hidden');
                    document.getElementById('draw-signature').classList.add('bg-primary', 'text-white');
                    document.getElementById('type-signature').classList.remove('bg-primary', 'text-white');
                    document.getElementById('initials-btn').classList.remove('bg-primary', 'text-white');
                    setSignatureColor(currentSignatureColor);
                    signaturePad?.clear(); // Clear pad when opening
                }
            });
            document.getElementById('image-tool').addEventListener('click', function() {
                toggleTool('image', 'image-tool-panel');
            });
            document.getElementById('highlight-tool').addEventListener('click', function() {
                toggleTool('highlight', 'highlight-tool-panel');
                if (activeTool === 'highlight') {
                     updateHighlightPanelColors(currentHighlightProperties.opacity); // Update preview colors based on initial opacity
                 }
            });
            document.getElementById('save-pdf').addEventListener('click', savePDF);

             // --- Tool Toggling Helper ---
             function toggleTool(toolName, panelId) {
                 if (activeTool === toolName) {
                    document.getElementById(panelId).style.display = 'none';
                    setActiveTool(null);
                 } else {
                    setActiveTool(toolName);
                    showToolPanel(panelId);
                 }
             }

            // --- Page Navigation & Zoom ---
            document.getElementById('page-select').addEventListener('change', function() {
                const selectedPage = parseInt(this.value);
                if (pdfDoc && selectedPage !== pageNum) {
                    pageNum = selectedPage;
                    queueRenderPage(pageNum);
                }
            });
            document.getElementById('zoom-in').addEventListener('click', () => updateZoom(0.25));
            document.getElementById('zoom-out').addEventListener('click', () => updateZoom(-0.25));

            function updateZoom(delta) {
                 if (!pdfDoc) return;
                 const newScale = Math.max(0.5, Math.min(3.0, scale + delta));
                 if (newScale !== scale) {
                     scale = newScale;
                     queueRenderPage(pageNum);
                 }
            }


            // --- PDF Viewer Interaction ---
            document.getElementById('pdf-viewer').addEventListener('click', function(e) {
                const clickedAnnotation = e.target.closest('.annotation');
                const clickedCanvasArea = e.target === canvas || e.target.closest('#pdf-render') && !clickedAnnotation;

                if (clickedAnnotation) {
                    // Handle click on existing annotation (selection, maybe focus text)
                     // If clicking on editable text *within the already selected annotation*, allow focus
                     if (selectedAnnotation === clickedAnnotation && e.target.classList.contains('editable-text')) {
                         // Let the browser handle focus
                         return;
                     }
                     // Otherwise, select the clicked annotation
                     selectAnnotation(clickedAnnotation);
                     // Prevent triggering canvas click below
                     return;

                } else if (clickedCanvasArea && activeTool && pdfDoc) {
                     // Handle click on canvas to add a *new* annotation (if tool active)
                     const rect = canvas.getBoundingClientRect();
                     const x = e.clientX - rect.left;
                     const y = e.clientY - rect.top;

                     // For tools that add instantly on click (text, highlight)
                     if (activeTool === 'text' || activeTool === 'highlight') {
                         addAnnotation(x, y);
                     }
                     // Signature/Image are added via their panel buttons, not direct canvas click

                 } else if (!clickedAnnotation && !e.target.closest('.tool-panel') && !e.target.closest('.group > button')) {
                    // Clicked outside annotations, panels, and toolbar buttons -> Deselect
                    clearSelection();
                    // Optionally deactivate tool? Maybe not, user might want to add another.
                    // setActiveTool(null); // Let's not deactivate tool on deselect
                }
            });

            // --- Text Tool Panel ---
            document.querySelectorAll('#text-tool-panel .font-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('#text-tool-panel .font-option').forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    currentTextProperties.fontFamily = this.style.fontFamily;
                    updateSelectedAnnotation();
                });
            });
            document.getElementById('text-size').addEventListener('input', function() {
                currentTextProperties.fontSize = parseInt(this.value);
                updateSelectedAnnotation();
            });
             document.querySelectorAll('#text-tool-panel .color-option').forEach(option => {
                 option.addEventListener('click', function() {
                     document.querySelectorAll('#text-tool-panel .color-option').forEach(opt => opt.classList.remove('selected'));
                     this.classList.add('selected');
                     currentTextProperties.color = this.dataset.color; // Store color name/identifier
                     updateSelectedAnnotation();
                 });
             });
            document.getElementById('bold-text').addEventListener('click', function() {
                currentTextProperties.bold = !currentTextProperties.bold;
                this.classList.toggle('bg-gray-200', currentTextProperties.bold);
                updateSelectedAnnotation();
            });
            document.getElementById('italic-text').addEventListener('click', function() {
                currentTextProperties.italic = !currentTextProperties.italic;
                this.classList.toggle('bg-gray-200', currentTextProperties.italic);
                updateSelectedAnnotation();
            });
            document.getElementById('underline-text').addEventListener('click', function() {
                currentTextProperties.underline = !currentTextProperties.underline;
                this.classList.toggle('bg-gray-200', currentTextProperties.underline);
                updateSelectedAnnotation();
            });


            // --- Signature Tool Panel ---
            document.getElementById('draw-signature').addEventListener('click', function() {
                document.getElementById('signature-draw-container').classList.remove('hidden');
                document.getElementById('signature-type-container').classList.add('hidden');
                document.getElementById('type-signature').classList.remove('bg-primary', 'text-white').add('bg-gray-100');
                document.getElementById('initials-btn').classList.remove('bg-primary', 'text-white').add('bg-gray-100');
                this.classList.add('bg-primary', 'text-white');
                this.classList.remove('bg-gray-100');
                resizeSignatureCanvas(); // Ensure canvas is ready
            });
             document.getElementById('type-signature').addEventListener('click', function() {
                 document.getElementById('signature-draw-container').classList.add('hidden');
                 document.getElementById('signature-type-container').classList.remove('hidden');
                 document.getElementById('signature-text').classList.remove('hidden');
                 document.getElementById('initials-text').classList.add('hidden');
                 document.getElementById('draw-signature').classList.remove('bg-primary', 'text-white').add('bg-gray-100');
                 document.getElementById('initials-btn').classList.remove('bg-primary', 'text-white').add('bg-gray-100');
                 this.classList.add('bg-primary', 'text-white');
                 this.classList.remove('bg-gray-100');
             });
             document.getElementById('initials-btn').addEventListener('click', function() {
                 document.getElementById('signature-draw-container').classList.add('hidden');
                 document.getElementById('signature-type-container').classList.remove('hidden');
                 document.getElementById('signature-text').classList.add('hidden');
                 document.getElementById('initials-text').classList.remove('hidden');
                 document.getElementById('draw-signature').classList.remove('bg-primary', 'text-white').add('bg-gray-100');
                 document.getElementById('type-signature').classList.remove('bg-primary', 'text-white').add('bg-gray-100');
                 this.classList.add('bg-primary', 'text-white');
                 this.classList.remove('bg-gray-100');
             });
            document.getElementById('clear-signature').addEventListener('click', function() {
                if (signaturePad) signaturePad.clear();
                document.getElementById('signature-text').value = '';
                document.getElementById('initials-text').value = '';
            });
             document.getElementById('save-signature').addEventListener('click', function() {
                 const drawContainerVisible = !document.getElementById('signature-draw-container').classList.contains('hidden');
                 const typeContainerVisible = !document.getElementById('signature-type-container').classList.contains('hidden');
                 const initialsVisible = !document.getElementById('initials-text').classList.contains('hidden');
                 const signatureTextVisible = !document.getElementById('signature-text').classList.contains('hidden');

                 let added = false;
                 if (drawContainerVisible && signaturePad && !signaturePad.isEmpty()) {
                     const signatureData = signaturePad.toDataURL('image/png'); // Use PNG for transparency
                     createSignatureAnnotation(signatureData, 'drawing');
                     added = true;
                 } else if (typeContainerVisible && initialsVisible && document.getElementById('initials-text').value) {
                     const initials = document.getElementById('initials-text').value;
                     createSignatureAnnotation(initials, 'initials'); // Color taken from currentTypedSignatureColor
                      added = true;
                 } else if (typeContainerVisible && signatureTextVisible && document.getElementById('signature-text').value) {
                    const text = document.getElementById('signature-text').value;
                    createSignatureAnnotation(text, 'typed'); // Color taken from currentTypedSignatureColor
                    added = true;
                 } else {
                      // Provide more specific feedback
                      if (drawContainerVisible && signaturePad?.isEmpty()) alert('Please draw your signature or switch to Type/Initials.');
                      else if (typeContainerVisible && initialsVisible && !document.getElementById('initials-text').value) alert('Please type your initials.');
                      else if (typeContainerVisible && signatureTextVisible && !document.getElementById('signature-text').value) alert('Please type your signature.');
                      else alert('Please create a signature, initials, or typed text first.');
                 }

                 if (added) {
                     // Clear inputs after adding
                     signaturePad?.clear();
                     document.getElementById('signature-text').value = '';
                     document.getElementById('initials-text').value = '';
                      // Optionally close panel after adding
                      // document.getElementById('signature-tool-panel').style.display = 'none';
                      // setActiveTool(null);
                 }
            });

            // --- Image Tool Panel ---
            document.getElementById('browse-images').addEventListener('click', () => document.getElementById('image-input').click());
            document.getElementById('image-input').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        createImageAnnotation(event.target.result);
                         // Optionally close panel after adding
                         // document.getElementById('image-tool-panel').style.display = 'none';
                         // setActiveTool(null);
                    };
                    reader.readAsDataURL(file);
                } else if (file) {
                     alert("Please select a valid image file.");
                     this.value = null; // Reset input
                 }
            });
             // Drag and Drop for Image (Optional but nice UX)
             const imageDropZone = document.querySelector('#image-tool-panel .border-dashed');
             imageDropZone.addEventListener('dragover', (e) => {
                 e.preventDefault();
                 e.stopPropagation();
                 imageDropZone.classList.add('border-primary', 'bg-indigo-50');
             });
             imageDropZone.addEventListener('dragleave', (e) => {
                 e.preventDefault();
                 e.stopPropagation();
                 imageDropZone.classList.remove('border-primary', 'bg-indigo-50');
             });
             imageDropZone.addEventListener('drop', (e) => {
                 e.preventDefault();
                 e.stopPropagation();
                 imageDropZone.classList.remove('border-primary', 'bg-indigo-50');
                 const file = e.dataTransfer.files[0];
                 if (file && file.type.startsWith('image/')) {
                     const reader = new FileReader();
                     reader.onload = (event) => createImageAnnotation(event.target.result);
                     reader.readAsDataURL(file);
                 } else if (file) {
                      alert("Please drop a valid image file.");
                  }
             });


            // --- Highlight Tool Panel ---
            document.querySelectorAll('#highlight-tool-panel .color-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('#highlight-tool-panel .color-option').forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    currentHighlightProperties.color = this.dataset.color;
                    updateSelectedAnnotation(); // Update existing highlight if selected
                });
            });
            document.getElementById('highlight-opacity').addEventListener('input', function() {
                currentHighlightProperties.opacity = parseInt(this.value) / 100;
                 updateHighlightPanelColors(currentHighlightProperties.opacity); // Update panel previews
                updateSelectedAnnotation(); // Update existing highlight if selected
            });
        }

        // --- PDF Loading and Rendering ---
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const typedArray = new Uint8Array(e.target.result);
                    // Clear existing state
                    annotations = [];
                    clearSelection();
                    setActiveTool(null);
                    pageNum = 1;
                    scale = 1.0;
                    pdfDoc = null;

                    loadPDF(typedArray);
                };
                reader.onerror = (e) => { console.error("File reading error:", e); alert('Error reading file.'); };
                reader.readAsArrayBuffer(file);
            } else if (file) {
                alert('Please select a valid PDF file.');
                event.target.value = null; // Reset file input
            }
        }

        function loadPDF(data) {
            pdfjsLib.getDocument(data).promise.then(function(pdf) {
                pdfDoc = pdf;
                const pageSelect = document.getElementById('page-select');
                pageSelect.innerHTML = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = '' + i; // Just page number
                    pageSelect.appendChild(option);
                }
                pageSelect.value = 1;
                pageNum = 1;
                queueRenderPage(1);
            }).catch(function(error) {
                console.error('Error loading PDF:', error);
                alert('Error loading PDF. The file might be corrupted or invalid.');
                renderBlankCanvas();
            });
        }

        function queueRenderPage(num) {
            if (pageRendering) {
                pageNumPending = num;
            } else {
                renderPage(num);
            }
        }

        function renderPage(num) {
            if (!pdfDoc) return;
            pageRendering = true;
            pageNum = num;
            document.getElementById('page-select').value = num;

            pdfDoc.getPage(num).then(function(page) {
                const viewport = page.getViewport({ scale: scale });
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                const pdfRenderDiv = document.getElementById('pdf-render');
                pdfRenderDiv.style.width = viewport.width + 'px';
                pdfRenderDiv.style.height = viewport.height + 'px';

                const renderContext = { canvasContext: ctx, viewport: viewport };
                const renderTask = page.render(renderContext);

                renderTask.promise.then(() => {
                    pageRendering = false;
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                    redrawAnnotations(); // Redraw annotations AFTER page render
                }).catch(error => {
                    console.error('Error rendering page:', error);
                    pageRendering = false;
                });
            }).catch(error => {
                console.error('Error getting page:', error);
                pageRendering = false;
            });
        }

        function renderBlankCanvas() {
            canvas.width = 800; canvas.height = 1000;
            const pdfRenderDiv = document.getElementById('pdf-render');
            pdfRenderDiv.style.width = canvas.width + 'px';
            pdfRenderDiv.style.height = canvas.height + 'px';

            ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#555555'; ctx.font = '20px Arial'; ctx.textAlign = 'center';
            ctx.fillText('Upload a PDF to start editing', canvas.width / 2, canvas.height / 2 - 20);
            ctx.font = '14px Arial';
            ctx.fillText('(Use the upload button on the left)', canvas.width / 2, canvas.height / 2 + 10);
            document.getElementById('page-select').innerHTML = '<option>N/A</option>';
            annotations = []; // Clear annotations too
            redrawAnnotations(); // Clear any visible annotations
        }

        // --- Tool State Management ---
        function setActiveTool(tool) {
             // Deactivate previous tool button styling
             if (activeTool && document.getElementById(`${activeTool}-tool`)) {
                 document.getElementById(`${activeTool}-tool`).classList.remove('active-tool');
             }
             // Hide all panels unless the new tool needs one
             document.querySelectorAll('.tool-panel').forEach(panel => panel.style.display = 'none');

             activeTool = tool;

             // Activate new tool button styling
             if (activeTool && document.getElementById(`${activeTool}-tool`)) {
                 document.getElementById(`${activeTool}-tool`).classList.add('active-tool');
             }

             // Change cursor based on tool
             canvas.style.cursor = (tool === 'text') ? 'text' :
                                  (tool === 'highlight') ? 'crosshair' : // Or maybe default?
                                  'default'; // Default for signature/image/null

            clearSelection(); // Clear selection when changing tools
        }

        function showToolPanel(panelId) {
             // Hide all panels first (redundant with setActiveTool, but safe)
             document.querySelectorAll('.tool-panel').forEach(panel => panel.style.display = 'none');
             // Show the specific panel if its ID is provided and a tool is active
             if (panelId && activeTool) {
                 const panel = document.getElementById(panelId);
                 if (panel) panel.style.display = 'block';
             }
        }

        // --- Annotation Creation ---
        function addAnnotation(x, y) {
            // This function now specifically handles TEXT and HIGHLIGHT added by direct click
            if (!activeTool || (activeTool !== 'text' && activeTool !== 'highlight') || !pdfDoc) return;

            const annotationId = 'annotation-' + Date.now();
            const annotationDiv = document.createElement('div');
            annotationDiv.className = 'annotation';
            annotationDiv.id = annotationId;
            annotationDiv.style.left = x + 'px';
            annotationDiv.style.top = y + 'px';

             let annotationData = {
                 id: annotationId,
                 type: activeTool,
                 page: pageNum,
                 x: x,
                 y: y,
                 width: 0, // Will be set below
                 height: 0, // Will be set below
                 properties: null,
                 content: null
             };

            // === Use the working TEXT logic from the second example ===
            if (activeTool === 'text') {
                 annotationDiv.style.width = '200px';
                 annotationDiv.style.height = '30px'; // Initial height

                 // Create an editable div with auto-focus
                 const editableDiv = document.createElement('div');
                 editableDiv.className = 'editable-text';
                 editableDiv.contentEditable = true;
                 editableDiv.textContent = "Type here";
                 editableDiv.style.fontFamily = currentTextProperties.fontFamily;
                 editableDiv.style.fontSize = currentTextProperties.fontSize + 'px';
                 editableDiv.style.color = currentTextProperties.color; // Direct color assignment
                 editableDiv.style.fontWeight = currentTextProperties.bold ? 'bold' : 'normal';
                 editableDiv.style.fontStyle = currentTextProperties.italic ? 'italic' : 'normal';
                 editableDiv.style.textDecoration = currentTextProperties.underline ? 'underline' : 'none';

                 // Focus immediately and place cursor at end
                 setTimeout(() => {
                     editableDiv.focus();
                     const range = document.createRange();
                     const sel = window.getSelection();
                     range.selectNodeContents(editableDiv);
                     range.collapse(false); // Collapse to the end
                     sel.removeAllRanges();
                     sel.addRange(range);
                 }, 0);

                 // Update stored content when input changes
                 editableDiv.addEventListener('input', function() {
                     const annotation = annotations.find(a => a.id === annotationId);
                     if (annotation) {
                         annotation.content = editableDiv.textContent;
                         // Optional: Adjust height based on content? More complex.
                         // annotation.height = annotationDiv.offsetHeight;
                         // annotation.width = annotationDiv.offsetWidth;
                     }
                 });

                 annotationDiv.appendChild(editableDiv);

                 // Store text-specific data
                 annotationData.width = parseInt(annotationDiv.style.width);
                 annotationData.height = parseInt(annotationDiv.style.height);
                 annotationData.properties = {...currentTextProperties};
                 annotationData.content = "Type here";

            }
            // === End of Text Logic ===
            else if (activeTool === 'highlight') {
                annotationDiv.style.width = '100px';
                annotationDiv.style.height = '20px';
                 const props = {...currentHighlightProperties};
                 annotationDiv.style.backgroundColor = highlightColorMap[props.color]?.replace('##OPACITY##', props.opacity) || 'rgba(255, 255, 0, 0.5)';
                 annotationDiv.style.zIndex = 4; // Place highlights slightly below text/signatures

                 // Store highlight-specific data
                 annotationData.width = parseInt(annotationDiv.style.width);
                 annotationData.height = parseInt(annotationDiv.style.height);
                 annotationData.properties = props;
            }

            // Add delete button (common to both)
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '×';
            // Use mousedown to prevent triggering click listeners on parent/canvas
            deleteBtn.onmousedown = function(event) {
                event.stopPropagation();
                deleteAnnotation(annotationDiv);
            };
            annotationDiv.appendChild(deleteBtn);

            // Set up drag and resize
            setupDraggable(annotationDiv);

            document.getElementById('pdf-container').appendChild(annotationDiv);
            annotations.push(annotationData);

            // Select the new annotation
            selectAnnotation(annotationDiv);
        }

        function createSignatureAnnotation(content, type) {
             if (!pdfDoc) return; // Don't add if no PDF loaded

             const signatureId = 'signature-' + Date.now();
             const signatureDiv = document.createElement('div');
             signatureDiv.className = 'annotation';
             signatureDiv.id = signatureId;
             signatureDiv.style.overflow = 'visible'; // Ensure content isn't clipped

             let sigWidth = 200;
             let sigHeight = (type === 'drawing') ? 80 : 60;

             signatureDiv.style.width = sigWidth + 'px';
             signatureDiv.style.height = sigHeight + 'px';
             signatureDiv.style.cursor = 'move';

             // Center the signature on the *visible* canvas part initially
             const container = document.getElementById('pdf-container');
             const viewer = document.getElementById('pdf-viewer');
             const canvasRect = canvas.getBoundingClientRect();
             const viewerRect = viewer.getBoundingClientRect();

             // Calculate center relative to viewer scroll position
             const centerX = viewer.scrollLeft + viewerRect.width / 2;
             const centerY = viewer.scrollTop + viewerRect.height / 2;

             // Convert viewer center to canvas coordinates
              let initialX = centerX - canvasRect.left - (sigWidth / 2);
              let initialY = centerY - canvasRect.top - (sigHeight / 2);

             // Clamp position to be within canvas bounds
             initialX = Math.max(0, Math.min(initialX, canvas.width - sigWidth));
             initialY = Math.max(0, Math.min(initialY, canvas.height - sigHeight));

             signatureDiv.style.left = initialX + 'px';
             signatureDiv.style.top = initialY + 'px';

             let properties = null;

             // Add content based on type
             if (type === 'drawing') {
                 signatureDiv.innerHTML = `<img src="${content}" style="width:100%; height:100%; object-fit: contain; display: block; pointer-events: none;" />`; // pointer-events none on img
             } else if (type === 'typed' || type === 'initials') {
                const font = document.getElementById('signature-font').value;
                const colorName = currentTypedSignatureColor;
                const colorHex = colorMap[colorName] || '#000000'; // Get hex for display
                properties = { font: font, color: colorName }; // Store color name

                signatureDiv.innerHTML = `<div style="font-family:${font}; color:${colorHex}; font-size:${type === 'initials' ? '32px' : '24px'}; width:100%; height:100%; display:flex; align-items:center; justify-content:center; white-space: nowrap; box-sizing: border-box; overflow: hidden; pointer-events: none;">${content}</div>`;
             }

            // Add delete button consistently
             const deleteBtn = document.createElement('div');
             deleteBtn.className = 'delete-btn';
             deleteBtn.innerHTML = '×';
             deleteBtn.onmousedown = function(event) { event.stopPropagation(); deleteAnnotation(signatureDiv); };
             signatureDiv.appendChild(deleteBtn);

            // Set up drag and resize
            setupDraggable(signatureDiv);

            container.appendChild(signatureDiv);

            // Store annotation data
            const annotation = {
                id: signatureId, type: 'signature', signatureType: type, page: pageNum,
                x: initialX, y: initialY, width: sigWidth, height: sigHeight,
                content: content, properties: properties
            };
            annotations.push(annotation);
            selectAnnotation(signatureDiv);
        }

        function createImageAnnotation(imageData) {
             if (!pdfDoc) return;
             const imageId = 'image-' + Date.now();
             const imageDiv = document.createElement('div');
             imageDiv.className = 'annotation';
             imageDiv.id = imageId;
             imageDiv.style.overflow = 'hidden'; // Image should clip to bounds

             let initialWidth = 200;
             imageDiv.style.width = initialWidth + 'px';
             imageDiv.style.height = 'auto'; // Determine height after load

             // Center the image like signature
             const container = document.getElementById('pdf-container');
             const viewer = document.getElementById('pdf-viewer');
             const canvasRect = canvas.getBoundingClientRect();
             const viewerRect = viewer.getBoundingClientRect();
             const centerX = viewer.scrollLeft + viewerRect.width / 2;
             const centerY = viewer.scrollTop + viewerRect.height / 2;
             let initialX = centerX - canvasRect.left - (initialWidth / 2);
             let initialY = centerY - canvasRect.top - 100; // Guess initial Y offset
             initialX = Math.max(0, Math.min(initialX, canvas.width - initialWidth));
             initialY = Math.max(0, Math.min(initialY, canvas.height - 150)); // Assume min height for clamping

             imageDiv.style.left = initialX + 'px';
             imageDiv.style.top = initialY + 'px';

             const img = document.createElement('img');
             img.src = imageData;
             img.style.width = '100%';
             img.style.height = '100%'; // Let object-fit handle aspect ratio
             img.style.objectFit = 'contain';
             img.style.display = 'block';
             img.style.pointerEvents = 'none'; // Prevent img interfering with drag/resize

             imageDiv.appendChild(img);

             const deleteBtn = document.createElement('div');
             deleteBtn.className = 'delete-btn';
             deleteBtn.innerHTML = '×';
             deleteBtn.onmousedown = function(event) { event.stopPropagation(); deleteAnnotation(imageDiv); };
             imageDiv.appendChild(deleteBtn);

             const annotation = {
                 id: imageId, type: 'image', page: pageNum,
                 x: initialX, y: initialY, width: initialWidth, height: 'auto', // Store 'auto' initially
                 content: imageData, properties: null
             };

             img.onload = function() {
                 const aspectRatio = img.naturalWidth / img.naturalHeight;
                 let loadedHeight = 150; // Default height if aspect ratio fails
                 if (aspectRatio && isFinite(aspectRatio)) {
                     loadedHeight = initialWidth / aspectRatio;
                 }
                 imageDiv.style.height = loadedHeight + 'px'; // Set specific height now

                 // Update stored annotation height
                 annotation.height = loadedHeight;
                 annotation.y = Math.min(initialY, canvas.height - loadedHeight); // Re-clamp Y pos based on actual height
                 imageDiv.style.top = annotation.y + 'px';


                 container.appendChild(imageDiv);
                 setupDraggable(imageDiv);
                 selectAnnotation(imageDiv);
             };
             img.onerror = function() {
                 console.error("Failed to load image for annotation:", img.src);
                 alert("Error loading image.");
                 // Don't add annotation if image fails
             };

             // Only add to annotations array *after* successful load via onload
             // Add to DOM inside onload too.
             annotations.push(annotation); // Add data structure first
             // Note: If onload fails, this entry should ideally be removed, but error handling is basic here.
        }

        // --- Annotation Manipulation ---

        function setupDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;
            let isResizing = false;
            const pdfContainer = document.getElementById('pdf-container');

            // Use mousedown on the element itself for dragging
            element.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                 // Ensure the click is directly on the annotation div or its non-interactive children
                 // (like the img or the text div background), but not on the delete button or resize handle.
                 if (e.target.classList.contains('delete-btn')) {
                     // Let the delete button's mousedown handle it
                     return;
                 }

                 // Check if clicking the resize handle area (bottom-right corner)
                 const rect = element.getBoundingClientRect();
                 const resizeHandleSize = 16; // Slightly larger clickable area for handle
                 const onResizeHandle =
                    e.clientX >= rect.right - resizeHandleSize && e.clientX <= rect.right + 2 && // Add tolerance
                    e.clientY >= rect.bottom - resizeHandleSize && e.clientY <= rect.bottom + 2;

                 if (onResizeHandle && element.style.resize !== 'none') { // Check if resizing is allowed
                     isResizing = true;
                     isDragging = false;
                     pos3 = e.clientX; // Store initial mouse position for resize delta
                     pos4 = e.clientY;
                      document.body.style.cursor = 'nwse-resize'; // Change cursor globally during resize
                 } else if (!e.target.classList.contains('editable-text') || element.style.cursor === 'move') {
                     // Only start dragging if not clicking inside editable text OR if cursor is already 'move'
                     // This allows text selection on first click inside editable area
                    isResizing = false;
                    isDragging = true;
                    pos3 = e.clientX; // Store initial mouse position for drag delta
                    pos4 = e.clientY;
                    element.style.cursor = 'move'; // Ensure move cursor for dragging
                 } else {
                     // Clicked inside editable text, don't start drag/resize immediately
                     isDragging = false;
                     isResizing = false;
                     return; // Allow text selection/editing
                 }

                e.preventDefault(); // Prevent default text selection/image dragging ONLY if starting drag/resize
                e.stopPropagation(); // Prevent triggering canvas click listener

                document.onmousemove = elementDrag;
                document.onmouseup = closeDragElement;
            }

            function elementDrag(e) {
                e.preventDefault();
                e.stopPropagation();

                if (isResizing) {
                     // Calculate the change in mouse position
                     const dx = e.clientX - pos3;
                     const dy = e.clientY - pos4;

                     let newWidth = element.offsetWidth + dx;
                     let newHeight = element.offsetHeight + dy;

                     // Enforce minimum size
                     const minWidth = 30;
                     const minHeight = 20;
                     newWidth = Math.max(minWidth, newWidth);
                     newHeight = Math.max(minHeight, newHeight);

                     // Constrain within parent bounds (consider right/bottom edges)
                     const parentWidth = pdfContainer.offsetWidth;
                     const parentHeight = pdfContainer.offsetHeight;
                     newWidth = Math.min(newWidth, parentWidth - element.offsetLeft);
                     newHeight = Math.min(newHeight, parentHeight - element.offsetTop);


                     element.style.width = newWidth + 'px';

                     // Handle image aspect ratio during resize
                     const img = element.querySelector('img');
                     const annotation = annotations.find(a => a.id === element.id);
                     if (annotation?.type === 'image' && img?.naturalWidth && img?.naturalHeight) {
                         const aspectRatio = img.naturalWidth / img.naturalHeight;
                         if (aspectRatio && isFinite(aspectRatio)) {
                             newHeight = newWidth / aspectRatio;
                             element.style.height = Math.max(minHeight, newHeight) + 'px';
                         } else {
                             element.style.height = newHeight + 'px'; // Free resize if no aspect ratio
                         }
                     } else {
                        element.style.height = newHeight + 'px'; // Free resize for non-images or text
                     }


                     // Update starting point for next delta calculation
                     pos3 = e.clientX;
                     pos4 = e.clientY;

                 } else if (isDragging) {
                    // Calculate the new cursor position offset
                    pos1 = pos3 - e.clientX;
                    pos2 = pos4 - e.clientY;
                    pos3 = e.clientX;
                    pos4 = e.clientY;

                    // Calculate new element position
                    let newTop = element.offsetTop - pos2;
                    let newLeft = element.offsetLeft - pos1;

                    // Constrain within parent bounds
                    const parentWidth = pdfContainer.offsetWidth;
                    const parentHeight = pdfContainer.offsetHeight;
                    newLeft = Math.max(0, Math.min(newLeft, parentWidth - element.offsetWidth));
                    newTop = Math.max(0, Math.min(newTop, parentHeight - element.offsetHeight));

                    // Set the element's new position
                    element.style.top = newTop + "px";
                    element.style.left = newLeft + "px";
                }

                // Update annotation data in the array (can be debounced for performance)
                 updateAnnotationData(element);
            }

            function closeDragElement(e) {
                 e.stopPropagation();
                 document.onmouseup = null;
                 document.onmousemove = null;
                 element.style.cursor = 'move'; // Reset cursor to move
                 document.body.style.cursor = 'default'; // Reset global cursor

                 if (isDragging || isResizing) {
                     // Final update of annotation data after drag/resize ends
                     updateAnnotationData(element);
                 }
                 isDragging = false;
                 isResizing = false;
            }

            function updateAnnotationData(el) {
                 const annotation = annotations.find(a => a.id === el.id);
                 if (annotation) {
                     annotation.x = el.offsetLeft;
                     annotation.y = el.offsetTop;
                     annotation.width = el.offsetWidth;
                     annotation.height = el.offsetHeight;
                     // If it's text, update content too (as resizing might wrap text differently, though contentEditable handles this visually)
                     if (annotation.type === 'text') {
                         const editableDiv = el.querySelector('.editable-text');
                         if (editableDiv) {
                             annotation.content = editableDiv.textContent; // Ensure content is synced
                         }
                     }
                 }
            }
        }

        function selectAnnotation(annotationElement) {
             if (!annotationElement) {
                 clearSelection();
                 return;
             }
            // If clicking the same annotation again, do nothing extra unless it's text focus
             if (selectedAnnotation === annotationElement) {
                // Allow focus to proceed if it's the editable part
                if (!event || !event.target.classList.contains('editable-text')) {
                    // If not clicking the text area itself, exit early.
                     return;
                 }
             }

            clearSelection(); // Clear previous styling and state

            annotationElement.classList.add('selected');
            selectedAnnotation = annotationElement; // Store the DOM element

            const annotation = annotations.find(a => a.id === annotationElement.id);
            if (!annotation) return;

             // Determine which tool and panel correspond to the annotation type
             let toolToActivate = annotation.type; // Usually match
             let panelToShow = null;

             switch (annotation.type) {
                 case 'text':
                     panelToShow = 'text-tool-panel';
                     updateTextPanelControls(annotation.properties); // Update controls from stored data
                     currentTextProperties = {...annotation.properties}; // Sync global state
                     // Ensure the text tool is visually active
                     if(activeTool !== 'text') setActiveToolButtonOnly('text');
                     break;
                 case 'highlight':
                     panelToShow = 'highlight-tool-panel';
                     updateHighlightPanelControls(annotation.properties);
                     currentHighlightProperties = {...annotation.properties};
                     if(activeTool !== 'highlight') setActiveToolButtonOnly('highlight');
                     break;
                 case 'signature':
                 case 'image':
                     // Selecting existing signature/image doesn't open their creation panels
                     // Keep the currently active tool button highlighted? Or clear it?
                     // Let's clear tool button highlight if selecting these types, but don't change activeTool variable
                     // This way, if text tool was active, clicking a signature doesn't prevent adding more text later.
                      setActiveToolButtonOnly(null); // Just remove button highlight
                     break;
                 default:
                     setActiveToolButtonOnly(null); // Clear button highlight for unknown types
                     break;
             }

             // Show the relevant panel (if any)
             if(panelToShow) {
                showToolPanel(panelToShow);
             } else {
                 // Hide all panels if no specific panel for this type
                 document.querySelectorAll('.tool-panel').forEach(panel => panel.style.display = 'none');
             }
        }

        // Helper to visually activate/deactivate tool button without changing activeTool state
         function setActiveToolButtonOnly(toolName) {
             document.querySelectorAll('.group > button[id$="-tool"]').forEach(btn => {
                 btn.classList.remove('active-tool');
             });
             if (toolName && document.getElementById(`${toolName}-tool`)) {
                 document.getElementById(`${toolName}-tool`).classList.add('active-tool');
             }
         }

        function clearSelection() {
            if (selectedAnnotation) {
                selectedAnnotation.classList.remove('selected');
            }
            selectedAnnotation = null;
             // Don't hide panels or change active tool here - let selection/tool changes handle that.
        }

        function updateSelectedAnnotation() {
            if (!selectedAnnotation) return;

            const annotation = annotations.find(a => a.id === selectedAnnotation.id);
            if (!annotation) return;

            if (annotation.type === 'text') {
                 // Update the properties in the annotation data store
                 annotation.properties = {...currentTextProperties};

                 // Update the visual appearance of the editable div
                 const editableDiv = selectedAnnotation.querySelector('.editable-text');
                 if (editableDiv) {
                     editableDiv.style.fontFamily = currentTextProperties.fontFamily;
                     editableDiv.style.fontSize = currentTextProperties.fontSize + 'px';
                     editableDiv.style.color = currentTextProperties.color; // Direct color
                     editableDiv.style.fontWeight = currentTextProperties.bold ? 'bold' : 'normal';
                     editableDiv.style.fontStyle = currentTextProperties.italic ? 'italic' : 'normal';
                     editableDiv.style.textDecoration = currentTextProperties.underline ? 'underline' : 'none';
                 }
            } else if (annotation.type === 'highlight') {
                // Update the properties in the annotation object
                annotation.properties = {...currentHighlightProperties};
                 // Update the visual appearance
                 const props = annotation.properties;
                 selectedAnnotation.style.backgroundColor = highlightColorMap[props.color]?.replace('##OPACITY##', props.opacity) || 'rgba(255, 255, 0, 0.5)';
            }
            // No visual update needed here for signature/image based on their *creation* panels
        }

        function deleteAnnotation(element) {
            if (!element || !element.id) return;
            const annotationId = element.id;

            // Remove from DOM
            element.remove();

            // Remove from annotations array
            annotations = annotations.filter(a => a.id !== annotationId);

            // Clear selection if this was the selected annotation
            if (selectedAnnotation && selectedAnnotation.id === annotationId) {
                 clearSelection();
                 // Optionally hide panels if the last annotation of a type was deleted? More complex state needed.
            }
        }

         function updateTextPanelControls(properties) {
              // Font Family
              let familyFound = false;
              document.querySelectorAll('#text-tool-panel .font-option').forEach(opt => {
                  opt.classList.remove('selected');
                  const targetFont = (properties.fontFamily || 'Arial').replace(/['"]/g, '').toLowerCase();
                  const optionFont = opt.style.fontFamily.replace(/['"]/g, '').toLowerCase();
                  if (optionFont.includes(targetFont) || targetFont.includes(optionFont)) {
                      opt.classList.add('selected');
                      familyFound = true;
                  }
              });
              if (!familyFound) { // Fallback if font name doesn't match exactly
                  document.querySelector('#text-tool-panel .font-option[style*="Arial"]')?.classList.add('selected');
              }
              // Font Size
              document.getElementById('text-size').value = properties.fontSize || 14;
              // Color
               document.querySelectorAll('#text-tool-panel .color-option').forEach(opt => {
                    // Check data-color against the stored color property
                    opt.classList.toggle('selected', opt.dataset.color === (properties.color || 'black'));
                });
                // If no color matches, select black as default
                if (!document.querySelector('#text-tool-panel .color-option.selected')) {
                    document.querySelector('#text-tool-panel .color-option[data-color="black"]')?.classList.add('selected');
                }
              // Styles
              document.getElementById('bold-text').classList.toggle('bg-gray-200', properties.bold || false);
              document.getElementById('italic-text').classList.toggle('bg-gray-200', properties.italic || false);
              document.getElementById('underline-text').classList.toggle('bg-gray-200', properties.underline || false);
         }

         function updateHighlightPanelControls(properties) {
             document.querySelectorAll('#highlight-tool-panel .color-option').forEach(opt => {
                 opt.classList.toggle('selected', opt.dataset.color === (properties.color || 'yellow'));
             });
             document.getElementById('highlight-opacity').value = (properties.opacity || 0.5) * 100;
             updateHighlightPanelColors(properties.opacity || 0.5); // Update preview colors
         }

        // Update background color of highlight panel options based on opacity slider
         function updateHighlightPanelColors(opacity) {
            document.querySelectorAll('#highlight-tool-panel .color-option').forEach(opt => {
                 const colorBase = highlightColorMap[opt.dataset.color] || highlightColorMap['yellow'];
                 opt.style.backgroundColor = colorBase.replace('##OPACITY##', opacity);
             });
         }


        function redrawAnnotations() {
             const container = document.getElementById('pdf-container');
             // Clear only annotation elements, leave canvas
             container.querySelectorAll('.annotation').forEach(el => el.remove());

             // Recreate annotations for the current page
             annotations.filter(a => a.page === pageNum).forEach(annotation => {
                 const annotationDiv = document.createElement('div');
                 annotationDiv.className = 'annotation';
                 annotationDiv.id = annotation.id;
                 annotationDiv.style.left = annotation.x + 'px';
                 annotationDiv.style.top = annotation.y + 'px';
                 annotationDiv.style.width = annotation.width + 'px';
                 // Use stored height, handle 'auto' case carefully (should be resolved by time it's stored)
                 annotationDiv.style.height = (typeof annotation.height === 'number' && annotation.height > 0) ? annotation.height + 'px' : '30px'; // Default fallback height
                 annotationDiv.style.overflow = 'visible'; // Default visible

                 const deleteBtn = document.createElement('div');
                 deleteBtn.className = 'delete-btn';
                 deleteBtn.innerHTML = '×';
                 deleteBtn.onmousedown = function(event) { event.stopPropagation(); deleteAnnotation(annotationDiv); };


                 if (annotation.type === 'text') {
                     const props = annotation.properties || currentTextProperties; // Use defaults if missing
                     const editableDiv = document.createElement('div');
                     editableDiv.className = 'editable-text';
                     editableDiv.contentEditable = true;
                     editableDiv.textContent = annotation.content || '';
                     editableDiv.style.fontFamily = props.fontFamily;
                     editableDiv.style.fontSize = props.fontSize + 'px';
                     editableDiv.style.color = props.color; // Direct color
                     editableDiv.style.fontWeight = props.bold ? 'bold' : 'normal';
                     editableDiv.style.fontStyle = props.italic ? 'italic' : 'normal';
                     editableDiv.style.textDecoration = props.underline ? 'underline' : 'none';

                     // Add input listener to update data store on change
                      editableDiv.addEventListener('input', function() {
                          annotation.content = editableDiv.textContent;
                          // Adjust height dynamically? - More complex, requires ResizeObserver or careful calculation
                          // annotation.height = annotationDiv.offsetHeight;
                      });

                     annotationDiv.appendChild(editableDiv);

                 } else if (annotation.type === 'highlight') {
                    const props = annotation.properties || currentHighlightProperties;
                     annotationDiv.style.backgroundColor = highlightColorMap[props.color]?.replace('##OPACITY##', props.opacity) || 'rgba(255, 255, 0, 0.5)';
                     annotationDiv.style.zIndex = 4;

                 } else if (annotation.type === 'signature') {
                    annotationDiv.style.overflow = 'visible'; // Ensure signature isn't clipped
                     if (annotation.signatureType === 'drawing') {
                         annotationDiv.innerHTML = `<img src="${annotation.content}" style="width:100%; height:100%; object-fit: contain; display: block; pointer-events: none;" />`;
                     } else { // Typed or Initials
                         const props = annotation.properties || {};
                         const font = props.font || "'Dancing Script', cursive";
                         const colorName = props.color || 'black';
                         const colorHex = colorMap[colorName] || '#000000';
                         annotationDiv.innerHTML = `<div style="font-family:${font}; color:${colorHex}; font-size:${annotation.signatureType === 'initials' ? '32px' : '24px'}; width:100%; height:100%; display:flex; align-items:center; justify-content:center; white-space: nowrap; overflow: hidden; box-sizing: border-box; pointer-events: none;">${annotation.content}</div>`;
                     }

                 } else if (annotation.type === 'image') {
                     annotationDiv.style.overflow = 'hidden'; // Clip image to bounds
                     const img = document.createElement('img');
                     img.src = annotation.content;
                     img.style.width = '100%';
                     img.style.height = '100%';
                     img.style.objectFit = 'contain';
                     img.style.display = 'block';
                     img.style.pointerEvents = 'none';
                     annotationDiv.appendChild(img);
                      // If height was stored as 'auto' and resolved later, ensure it's applied correctly
                     if (typeof annotation.height === 'number') {
                         annotationDiv.style.height = annotation.height + 'px';
                     } else {
                         // Attempt to reload and set height if 'auto' persisted (shouldn't happen ideally)
                         img.onload = () => {
                            if(typeof annotation.height !== 'number'){
                                const aspectRatio = img.naturalWidth / img.naturalHeight;
                                let loadedHeight = 150;
                                if (aspectRatio && isFinite(aspectRatio)) {
                                    loadedHeight = annotationDiv.offsetWidth / aspectRatio;
                                }
                                annotationDiv.style.height = loadedHeight + 'px';
                                annotation.height = loadedHeight; // Persist resolved height
                            }
                         }
                     }
                 }

                 annotationDiv.appendChild(deleteBtn); // Add delete button last
                 setupDraggable(annotationDiv);
                 container.appendChild(annotationDiv);

                 // Reselect if it was selected
                 if (selectedAnnotation && selectedAnnotation.id === annotation.id) {
                     annotationDiv.classList.add('selected');
                     selectedAnnotation = annotationDiv; // Update reference
                 }
             });
        }


        // --- PDF Saving ---
        async function savePDF() {
            if (!pdfDoc) { alert('No PDF loaded to save.'); return; }

            const saveBtn = document.getElementById('save-pdf');
            const originalIcon = saveBtn.innerHTML;
            saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            saveBtn.disabled = true;
            console.log('Starting PDF save...');

            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ unit: 'pt', compress: true });

                const originalFilename = document.getElementById('file-input').files[0]?.name || 'edited-document.pdf';
                const newFilename = originalFilename.replace(/\.pdf$/i, '-edited.pdf');

                const loadImage = (src) => new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = (err) => { console.error("Image load error:", src, err); reject(new Error('Failed to load image: ' + src)); };
                    img.src = src;
                });

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');

                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    console.log(`Processing page ${i} / ${pdfDoc.numPages}`);
                    const page = await pdfDoc.getPage(i);
                    // Render at scale 1.0 for saving (native PDF size)
                    const viewport = page.getViewport({ scale: 1.0 });

                    tempCanvas.width = viewport.width;
                    tempCanvas.height = viewport.height;

                    // 1. Render original PDF page onto temp canvas
                    const renderContext = { canvasContext: tempCtx, viewport: viewport };
                    await page.render(renderContext).promise;
                    console.log(` Page ${i}: PDF rendered.`);

                    // 2. Draw annotations for *this page* onto the temp canvas
                    const pageAnnotations = annotations.filter(a => a.page === i);
                    console.log(` Page ${i}: Found ${pageAnnotations.length} annotations.`);

                    // Process annotations sequentially
                    for (const annotation of pageAnnotations) {
                         // IMPORTANT: Convert annotation coordinates/sizes (relative to display 'scale')
                         // back to the native PDF scale (1.0)
                         const scaledX = annotation.x / scale;
                         const scaledY = annotation.y / scale;
                         const scaledWidth = annotation.width / scale;
                         // Ensure height is a number, resolve 'auto' if necessary (though it should be resolved before save)
                         let scaledHeight = (typeof annotation.height === 'number') ? annotation.height / scale : 30 / scale; // Default height fallback
                         const props = annotation.properties || {}; // Ensure props object exists

                         tempCtx.save(); // Save context state before drawing each annotation
                         console.log(`  Drawing ${annotation.type} annotation ${annotation.id}`);

                         try {
                             if (annotation.type === 'text') {
                                const fontSize = (props.fontSize || 14) / scale; // Scale font size
                                const fontFamily = props.fontFamily || 'Arial';
                                const fontWeight = props.bold ? 'bold ' : '';
                                const fontStyle = props.italic ? 'italic ' : '';
                                tempCtx.font = `${fontWeight}${fontStyle}${fontSize}px ${fontFamily}`;
                                tempCtx.fillStyle = props.color || 'black'; // Use direct color
                                tempCtx.textBaseline = 'top'; // Crucial for positioning multi-line text

                                // Handle potential multi-line text (simple split by newline)
                                const lines = (annotation.content || '').split('\n');
                                const lineHeight = fontSize * 1.2; // Estimate line height

                                // Draw each line
                                for(let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                                    const lineY = scaledY + (lineIndex * lineHeight);
                                    tempCtx.fillText(lines[lineIndex], scaledX, lineY);

                                     // Draw underline if needed
                                     if (props.underline) {
                                         const textMetrics = tempCtx.measureText(lines[lineIndex]);
                                         const underlineY = lineY + fontSize + 1; // Position slightly below baseline
                                         tempCtx.beginPath();
                                         tempCtx.strokeStyle = tempCtx.fillStyle; // Use text color
                                         tempCtx.lineWidth = Math.max(0.5, 1 / scale); // Thin line
                                         tempCtx.moveTo(scaledX, underlineY);
                                         tempCtx.lineTo(scaledX + textMetrics.width, underlineY);
                                         tempCtx.stroke();
                                     }
                                }

                             } else if (annotation.type === 'highlight') {
                                const colorKey = props.color || 'yellow';
                                const opacity = props.opacity || 0.5;
                                const colorRgba = highlightColorMap[colorKey]?.replace('##OPACITY##', opacity) || `rgba(255, 255, 0, ${opacity})`;
                                tempCtx.fillStyle = colorRgba;
                                // tempCtx.globalAlpha = opacity; // Setting alpha via fillStyle is often better
                                tempCtx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                                // tempCtx.globalAlpha = 1.0; // Reset if using globalAlpha


                             } else if (annotation.type === 'signature') {
                                 if (annotation.signatureType === 'drawing') {
                                     const img = await loadImage(annotation.content);
                                     tempCtx.drawImage(img, scaledX, scaledY, scaledWidth, scaledHeight);
                                 } else { // Typed or Initials
                                     const fontSize = ((annotation.signatureType === 'initials' ? 32 : 24) / scale); // Approx scale font size
                                     const fontFamily = props.font || 'Arial';
                                     const colorName = props.color || 'black';
                                     tempCtx.font = `${fontSize}px ${fontFamily}`;
                                     tempCtx.fillStyle = colorMap[colorName] || '#000000';
                                     tempCtx.textAlign = 'center';
                                     tempCtx.textBaseline = 'middle';
                                     // Draw text centered within the annotation box
                                     tempCtx.fillText(annotation.content, scaledX + scaledWidth / 2, scaledY + scaledHeight / 2);
                                 }

                             } else if (annotation.type === 'image') {
                                 const img = await loadImage(annotation.content);
                                 tempCtx.drawImage(img, scaledX, scaledY, scaledWidth, scaledHeight);
                             }

                         } catch (drawError) {
                             console.error(`Error drawing annotation ${annotation.id} (type: ${annotation.type}) on page ${i}:`, drawError);
                         } finally {
                             tempCtx.restore(); // Restore context state
                         }
                     } // End loop through annotations for the page

                    // 3. Add the composed page (canvas content) to the jsPDF document
                    const imgData = tempCanvas.toDataURL('image/png'); // Use PNG for better quality of text/lines

                    if (i > 1) {
                        doc.addPage([viewport.width, viewport.height], 'portrait');
                    }
                    // Add image stretched to full page size
                    doc.addImage(imgData, 'PNG', 0, 0, viewport.width, viewport.height, undefined, 'FAST'); // Use FAST compression
                    console.log(` Page ${i} added to jsPDF doc.`);

                } // End page loop

                console.log('Saving PDF...');
                doc.save(newFilename);
                console.log('PDF save initiated.');

            } catch (error) {
                console.error('Error during PDF saving process:', error);
                alert('An error occurred while saving the PDF. See console for details.');
            } finally {
                // Restore save button state
                saveBtn.innerHTML = originalIcon;
                saveBtn.disabled = false;
                console.log('Save process finished.');
            }
        }

        // --- Global Helper Functions ---
        // (Make functions globally accessible for inline event handlers if needed)
        window.setSignatureColor = function(colorName) {
             currentSignatureColor = colorName;
             if (signaturePad) {
                 signaturePad.penColor = colorMap[colorName] || '#000000';
             }
             // Update selected indicator
             document.querySelectorAll('#signature-draw-container .color-option').forEach(opt => {
                 opt.classList.toggle('selected', opt.dataset.color === colorName);
             });
         };
        window.setTypedSignatureColor = function(colorName) {
             currentTypedSignatureColor = colorName;
             // Update selected indicator
             document.querySelectorAll('#signature-type-container .color-option').forEach(opt => {
                 opt.classList.toggle('selected', opt.dataset.color === colorName);
             });
         };

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PDF Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/signature_pad/1.5.3/signature_pad.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5',
                        secondary: '#6B7280',
                        accent: '#10B981',
                        danger: '#EF4444',
                    }
                }
            }
        }
    </script>
    <style>
        #pdf-render {
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin: 0 auto;
            position: relative;
            overflow: hidden;
        }
        .canvas-container {
            position: relative;
            margin: 0 auto;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .annotation {
            position: absolute;
            cursor: move;
            resize: both;
            /* overflow: hidden; */ /* Removed to prevent clipping content like text */
            min-width: 50px;
            min-height: 20px;
            border: 1px dashed transparent;
            z-index: 5; /* Ensure annotations are above the canvas - Re-applying for certainty */
        }
        .annotation:hover {
            border-color: #4F46E5;
        }
        .annotation.selected {
            border: 1px dashed #4F46E5;
            background-color: rgba(79, 70, 229, 0.1);
        }
        .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background-color: #EF4444;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .annotation:hover .delete-btn {
            opacity: 1;
        }
        #signature-pad {
            border: 1px solid #e5e7eb;
            background-color: white;
            touch-action: none;
            width: 100%;
        }
        .tool-panel {
            position: absolute;
            left: 70px;
            top: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 10px;
            z-index: 100;
            width: 250px;
            display: none;
        }
        .color-option {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            margin: 3px;
            border: 2px solid white;
        }
        .color-option.selected {
            border-color: #4F46E5;
            transform: scale(1.1);
        }
        .font-option {
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        .font-option.selected {
            background-color: #E5E7EB;
            font-weight: bold;
        }
        .tooltip-text {
            position: absolute;
            left: 60px;
            background-color: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            white-space: nowrap;
            z-index: 1000;
        }
        .group:hover .tooltip-text {
            opacity: 1;
        }
        #signature-type-container {
            margin-top: 10px;
        }
        #file-input {
            display: none;
        }
        #initials-text {
            display: none;
        }
        .active-tool {
            background-color: #4F46E5 !important;
            color: white !important;
        }
        /* Resize handle styling */
        .annotation::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: #4F46E5;
            border-radius: 2px;
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .annotation:hover::after {
            opacity: 1;
        }
        /* Editable text area */
        .editable-text {
            min-height: 20px;
            width: 100%;
             height: 100%; /* Make it fill the annotation */
            outline: none;
            padding: 4px; /* Slightly more padding */
            cursor: text;
             color: black; /* Explicitly set default text color */
             background-color: transparent; /* Ensure no background */
             position: relative; /* Needed? Maybe not, but doesn't hurt */
             z-index: 1; /* Ensure text is above annotation background if any */
             box-sizing: border-box; /* Include padding in height/width */
             word-wrap: break-word; /* Wrap long text */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="flex h-screen overflow-hidden">
        <!-- Left Toolbar -->
        <div class="w-16 bg-white shadow-md flex flex-col items-center py-4 space-y-6">
            <!-- Upload PDF Button -->
            <div class="group relative">
                <button id="upload-btn" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-file-upload text-gray-700"></i>
                </button>
                <input type="file" id="file-input" accept=".pdf">
                <span class="tooltip-text">Upload PDF</span>
            </div>
            
            <!-- Text Tool -->
            <div class="group relative">
                <button id="text-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-font text-gray-700"></i>
                </button>
                <span class="tooltip-text">Text Tool</span>
            </div>
            
            <!-- Signature Tool -->
            <div class="group relative">
                <button id="signature-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-signature text-gray-700"></i>
                </button>
                <span class="tooltip-text">Signature/Initials</span>
            </div>
            
            <!-- Image Tool -->
            <div class="group relative">
                <button id="image-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-image text-gray-700"></i>
                </button>
                <span class="tooltip-text">Image Tool</span>
            </div>
            
            <!-- Highlight Tool -->
            <div class="group relative">
                <button id="highlight-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-highlighter text-gray-700"></i>
                </button>
                <span class="tooltip-text">Highlight Tool</span>
            </div>
            
            <!-- Save Button -->
            <div class="group relative mt-auto">
                <button id="save-pdf" class="w-12 h-12 rounded-lg flex items-center justify-center bg-primary hover:bg-purple-700 transition text-white">
                    <i class="fas fa-save"></i>
                </button>
                <span class="tooltip-text">Save PDF</span>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Top Bar -->
            <div class="bg-white shadow-sm py-3 px-4 flex items-center justify-between">
                <h1 class="text-xl font-semibold text-gray-800">PDF Editor</h1>
                <div class="flex items-center space-x-4">
                    <div>
                        <span class="text-gray-600 mr-2">Page:</span>
                        <select id="page-select" class="border rounded px-2 py-1">
                            <!-- Pages will be added dynamically -->
                        </select>
                    </div>
                    <button id="zoom-in" class="w-8 h-8 rounded flex items-center justify-center hover:bg-gray-100">
                        <i class="fas fa-search-plus text-gray-600"></i>
                    </button>
                    <button id="zoom-out" class="w-8 h-8 rounded flex items-center justify-center hover:bg-gray-100">
                        <i class="fas fa-search-minus text-gray-600"></i>
                    </button>
                </div>
            </div>

            <!-- PDF Viewer -->
            <div class="flex-1 overflow-auto p-6 bg-gray-50" id="pdf-viewer">
                <div id="pdf-container" class="relative mx-auto">
                    <div id="pdf-render" class="canvas-container">
                        <canvas id="pdf-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Text Tool Panel -->
        <div id="text-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Text Properties</h3>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Font Family</label>
                <div class="flex flex-wrap">
                    <div class="font-option selected" style="font-family: 'Arial'">Arial</div>
                    <div class="font-option" style="font-family: 'Times New Roman'">Times</div>
                    <div class="font-option" style="font-family: 'Courier New'">Courier</div>
                    <div class="font-option" style="font-family: 'Georgia'">Georgia</div>
                    <div class="font-option" style="font-family: 'Verdana'">Verdana</div>
                    <div class="font-option" style="font-family: 'Comic Sans MS'">Comic</div>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Font Size</label>
                <input type="range" id="text-size" min="8" max="72" value="14" class="w-full">
                <div class="flex justify-between text-xs text-gray-600">
                    <span>8</span>
                    <span>20</span>
                    <span>32</span>
                    <span>44</span>
                    <span>56</span>
                    <span>72</span>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Text Color</label>
                <div class="flex flex-wrap">
                    <div class="color-option bg-black selected" data-color="black"></div>
                    <div class="color-option bg-red-500" data-color="red"></div>
                    <div class="color-option bg-blue-500" data-color="blue"></div>
                    <div class="color-option bg-green-500" data-color="green"></div>
                    <div class="color-option bg-yellow-500" data-color="yellow"></div>
                    <div class="color-option bg-purple-500" data-color="purple"></div>
                    <div class="color-option bg-pink-500" data-color="pink"></div>
                    <div class="color-option bg-gray-500" data-color="gray"></div>
                </div>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Bold/Italic</label>
                <div class="flex">
                    <button id="bold-text" class="px-3 py-1 border rounded-l hover:bg-gray-100">
                        <i class="fas fa-bold"></i>
                    </button>
                    <button id="italic-text" class="px-3 py-1 border-t border-b hover:bg-gray-100">
                        <i class="fas fa-italic"></i>
                    </button>
                    <button id="underline-text" class="px-3 py-1 border rounded-r hover:bg-gray-100">
                        <i class="fas fa-underline"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Signature Tool Panel -->
        <div id="signature-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Add Signature/Initials</h3>
            <div class="mb-4">
                <div class="flex space-x-3 mb-3">
                    <button id="draw-signature" class="flex-1 py-2 bg-primary text-white rounded hover:bg-purple-700">Draw</button>
                    <button id="type-signature" class="flex-1 py-2 bg-gray-100 rounded hover:bg-gray-200">Type</button>
                    <button id="initials-btn" class="flex-1 py-2 bg-gray-100 rounded hover:bg-gray-200">Initials</button>
                </div>
                <div id="signature-draw-container" class="border rounded mb-3">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-sm font-medium text-gray-700">Pen Color:</label>
                        <div class="flex">
                            <div class="color-option bg-black selected" data-color="black" onclick="setSignatureColor('black')"></div>
                            <div class="color-option bg-red-500" data-color="red" onclick="setSignatureColor('red')"></div>
                            <div class="color-option bg-blue-500" data-color="blue" onclick="setSignatureColor('blue')"></div>
                            <div class="color-option bg-green-500" data-color="green" onclick="setSignatureColor('green')"></div>
                        </div>
                    </div>
                    <canvas id="signature-pad" height="150"></canvas>
                </div>
                <div id="signature-type-container" class="mb-3 hidden">
                    <input type="text" id="signature-text" placeholder="Type your name" class="w-full border rounded px-3 py-2">
                    <input type="text" id="initials-text" placeholder="Type your initials" class="w-full border rounded px-3 py-2 mt-2 hidden">
                    <div class="flex mt-2">
                        <select id="signature-font" class="border rounded px-2 py-1 flex-1 mr-2">
                            <option value="'Brush Script MT', cursive">Brush Script</option>
                            <option value="'Dancing Script', cursive">Dancing Script</option>
                            <option value="'Parisienne', cursive">Parisienne</option>
                            <option value="'Great Vibes', cursive">Great Vibes</option>
                        </select>
                        <div class="flex">
                            <div class="color-option bg-black selected" data-color="black" onclick="setTypedSignatureColor('black')"></div>
                            <div class="color-option bg-red-500" data-color="red" onclick="setTypedSignatureColor('red')"></div>
                            <div class="color-option bg-blue-500" data-color="blue" onclick="setTypedSignatureColor('blue')"></div>
                            <div class="color-option bg-green-500" data-color="green" onclick="setTypedSignatureColor('green')"></div>
                            <div class="color-option bg-purple-500" data-color="purple" onclick="setTypedSignatureColor('purple')"></div>
                        </div>
                    </div>
                </div>
                <div class="flex justify-between">
                    <button id="clear-signature" class="px-3 py-2 bg-gray-200 rounded hover:bg-gray-300">
                        Clear
                    </button>
                    <button id="save-signature" class="px-3 py-2 bg-primary text-white rounded hover:bg-purple-700">
                        Save
                    </button>
                </div>
            </div>
        </div>

        <!-- Image Tool Panel -->
        <div id="image-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Add Image</h3>
            <div class="mb-4">
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center">
                    <i class="fas fa-image text-4xl text-gray-400 mb-2"></i>
                    <p class="text-sm text-gray-500">Drag & drop image here or</p>
                    <button id="browse-images" class="mt-2 px-4 py-2 bg-primary text-white rounded hover:bg-purple-700">
                        Browse Files
                    </button>
                    <input type="file" id="image-input" accept="image/*" class="hidden">
                </div>
            </div>
        </div>

        <!-- Highlight Tool Panel -->
        <div id="highlight-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Highlight Properties</h3>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Highlight Color</label>
                <div class="flex flex-wrap">
                    <div class="color-option bg-yellow-200 selected" data-color="yellow"></div>
                    <div class="color-option bg-green-200" data-color="green"></div>
                    <div class="color-option bg-blue-200" data-color="blue"></div>
                    <div class="color-option bg-pink-200" data-color="pink"></div>
                    <div class="color-option bg-purple-200" data-color="purple"></div>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Opacity</label>
                <input type="range" id="highlight-opacity" min="30" max="100" value="50" class="w-full">
                <div class="flex justify-between text-xs text-gray-600">
                    <span>30%</span>
                    <span>65%</span>
                    <span>100%</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // PDF.js setup
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
        
        // Global variables
        let pdfDoc = null,
            pageNum = 1,
            pageRendering = false,
            pageNumPending = null,
            scale = 1.0,
            canvas = document.getElementById('pdf-canvas'),
            ctx = canvas.getContext('2d'),
            activeTool = null,
            annotations = [],
            selectedAnnotation = null,
            signaturePad = null,
            currentSignatureColor = 'black',
            currentTypedSignatureColor = 'black',
            currentTextProperties = {
                fontFamily: 'Arial',
                fontSize: 14,
                color: 'black',
                bold: false,
                italic: false,
                underline: false
            },
            currentHighlightProperties = {
                color: 'yellow',
                opacity: 0.5
            };

        // Initialize the editor
        document.addEventListener('DOMContentLoaded', function() {
            // Set up UI event listeners
            setupEventListeners();
            
            // Initialize signature pad with proper cursor positioning
            const signatureCanvas = document.getElementById('signature-pad');
            signaturePad = new SignaturePad(signatureCanvas, {
                backgroundColor: 'rgba(255, 255, 255, 0)',
                penColor: 'rgb(0, 0, 0)',
                onBegin: function() {
                    // Fix cursor positioning issue
                    const rect = signatureCanvas.getBoundingClientRect();
                    const lastPoint = signaturePad._data[signaturePad._data.length - 2];
                    if (lastPoint) {
                        signaturePad._data[signaturePad._data.length - 1] = {
                            x: (lastPoint.x * rect.width) / signatureCanvas.offsetWidth,
                            y: (lastPoint.y * rect.height) / signatureCanvas.offsetHeight,
                            time: Date.now()
                        };
                    }
                }
            });
            
            // Resize signature canvas when window resizes
            window.addEventListener('resize', resizeSignatureCanvas);
            resizeSignatureCanvas();
            
            // Load a default blank state
            renderBlankCanvas();
        });

        function resizeSignatureCanvas() {
            const canvas = document.getElementById('signature-pad');
            const ratio = Math.max(window.devicePixelRatio || 1, 1);
            canvas.width = canvas.offsetWidth * ratio;
            canvas.height = canvas.offsetHeight * ratio;
            canvas.getContext('2d').scale(ratio, ratio);
            signaturePad.clear(); // Clear the signature after resize
        }

        function setupEventListeners() {
            // Tool buttons
            document.getElementById('upload-btn').addEventListener('click', function() {
                document.getElementById('file-input').click();
            });
            
            document.getElementById('file-input').addEventListener('change', handleFileSelect);
            
            document.getElementById('text-tool').addEventListener('click', function() {
                if (activeTool === 'text') {
                    document.getElementById('text-tool-panel').style.display = 'none';
                    setActiveTool(null);
                } else {
                    setActiveTool('text');
                    showToolPanel('text-tool-panel');
                }
            });
            
            document.getElementById('signature-tool').addEventListener('click', function() {
                if (activeTool === 'signature') {
                    document.getElementById('signature-tool-panel').style.display = 'none';
                    setActiveTool(null);
                } else {
                    setActiveTool('signature');
                    showToolPanel('signature-tool-panel');
                    document.getElementById('signature-draw-container').classList.remove('hidden');
                 const signatureCanvas = document.getElementById('signature-pad');
                 signaturePad = new SignaturePad(signatureCanvas, {
                      backgroundColor: 'rgba(255, 255, 255, 0)',
                      penColor: 'rgb(0, 0, 0)',
                      onBegin: function() {
                           // Fix cursor positioning issue
                           const rect = signatureCanvas.getBoundingClientRect();
                           const lastPoint = signaturePad._data[signaturePad._data.length - 2];
                           if (lastPoint) {
                            signaturePad._data[signaturePad._data.length - 1] = {
                                 x: (lastPoint.x * rect.width) / signatureCanvas.offsetWidth,
                                 y: (lastPoint.y * rect.height) / signatureCanvas.offsetHeight,
                                 time: Date.now()
                            };
                           }
                      }
                 });
                 document.getElementById('signature-type-container').classList.add('hidden');
                    document.getElementById('initials-text').classList.add('hidden');
                    document.getElementById('signature-text').classList.remove('hidden');
                    document.getElementById('draw-signature').classList.add('bg-primary', 'text-white');
                    document.getElementById('type-signature').classList.remove('bg-primary', 'text-white');
                    document.getElementById('initials-btn').classList.remove('bg-primary', 'text-white');
                    setSignatureColor(currentSignatureColor);
                }
            });
            
            document.getElementById('image-tool').addEventListener('click', function() {
                if (activeTool === 'image') {
                    document.getElementById('image-tool-panel').style.display = 'none';
                    setActiveTool(null);
                } else {
                    setActiveTool('image');
                    showToolPanel('image-tool-panel');
                }
            });
            
            document.getElementById('highlight-tool').addEventListener('click', function() {
                if (activeTool === 'highlight') {
                    document.getElementById('highlight-tool-panel').style.display = 'none';
                    setActiveTool(null);
                } else {
                    setActiveTool('highlight');
                    showToolPanel('highlight-tool-panel');
                }
            });
            
            document.getElementById('save-pdf').addEventListener('click', savePDF);
            
            // Page navigation
            document.getElementById('page-select').addEventListener('change', function() {
                const selectedPage = parseInt(this.value);
                if (pdfDoc && selectedPage !== pageNum) {
                    pageNum = selectedPage;
                    queueRenderPage(pageNum);
                }
            });
            
            document.getElementById('zoom-in').addEventListener('click', function() {
                if (scale < 3.0) {
                    scale += 0.25;
                    queueRenderPage(pageNum);
                }
            });
            
            document.getElementById('zoom-out').addEventListener('click', function() {
                if (scale > 0.5) {
                    scale -= 0.25;
                    queueRenderPage(pageNum);
                }
            });
            
            // Click on PDF viewer
            document.getElementById('pdf-viewer').addEventListener('click', function(e) {
                if (!activeTool) return;
                
                // Check if clicked on an annotation
                const clickedAnnotation = e.target.closest('.annotation');
                if (clickedAnnotation) {
                    // If clicking on editable text, focus it but keep panel open
                    if (clickedAnnotation.querySelector('.editable-text') &&
                        e.target === clickedAnnotation.querySelector('.editable-text')) {
                         selectAnnotation(clickedAnnotation); // Re-select to ensure panel updates
                         return;
                    }
                    
                    // Otherwise select the annotation
                    selectAnnotation(clickedAnnotation);
                    return;
                }
                
                // Check if clicked on the canvas area (not on an existing annotation or panel)
                 if (!e.target.closest('.tool-panel') && (e.target === canvas || e.target === document.getElementById('pdf-render') ||
                     e.target === document.getElementById('pdf-container'))) {

                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    addAnnotation(x, y);
                     // Don't hide panel or deactivate tool immediately after adding
                     // Deactivation/panel hiding is now handled by the global listener
                }
            });
            
            // Text tool panel interactions
            document.querySelectorAll('.font-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.font-option').forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    currentTextProperties.fontFamily = this.style.fontFamily;
                    updateSelectedAnnotation();
                });
            });
            
            document.getElementById('text-size').addEventListener('input', function() {
                currentTextProperties.fontSize = parseInt(this.value);
                updateSelectedAnnotation();
            });
            
            document.querySelectorAll('.color-option').forEach(option => {
                option.addEventListener('click', function() {
                    const panelId = this.closest('.tool-panel')?.id;
                    if (!panelId) return; // Should always find a panel

                    document.querySelectorAll(`#${panelId} .color-option`).forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    
                    const color = this.dataset.color;

                    if (panelId === 'text-tool-panel') {
                        currentTextProperties.color = color;
                         updateSelectedAnnotation(); // Update selected text if any
                    } else if (panelId === 'signature-tool-panel') {
                        if (this.closest('#signature-type-container')) {
                            setTypedSignatureColor(color);
                        } else {
                            setSignatureColor(color);
                        }
                    } else if (panelId === 'highlight-tool-panel') {
                         currentHighlightProperties.color = color;
                         updateSelectedAnnotation(); // Update selected highlight if any
                    }
                });
            });
            
            document.getElementById('bold-text').addEventListener('click', function() {
                currentTextProperties.bold = !currentTextProperties.bold;
                this.classList.toggle('bg-gray-200');
                updateSelectedAnnotation();
            });
            
            document.getElementById('italic-text').addEventListener('click', function() {
                currentTextProperties.italic = !currentTextProperties.italic;
                this.classList.toggle('bg-gray-200');
                updateSelectedAnnotation();
            });
            
            document.getElementById('underline-text').addEventListener('click', function() {
                currentTextProperties.underline = !currentTextProperties.underline;
                this.classList.toggle('bg-gray-200');
                updateSelectedAnnotation();
            });
            
            // Signature tool panel
            document.getElementById('draw-signature').addEventListener('click', function() {
                document.getElementById('signature-draw-container').classList.remove('hidden');
                document.getElementById('signature-type-container').classList.add('hidden');
                document.getElementById('type-signature').classList.remove('bg-primary', 'text-white');
                document.getElementById('initials-btn').classList.remove('bg-primary', 'text-white');
                this.classList.add('bg-primary', 'text-white');
            });
            
            document.getElementById('type-signature').addEventListener('click', function() {
                document.getElementById('signature-draw-container').classList.add('hidden');
                document.getElementById('signature-type-container').classList.remove('hidden');
                document.getElementById('signature-text').classList.remove('hidden');
                document.getElementById('initials-text').classList.add('hidden');
                document.getElementById('draw-signature').classList.remove('bg-primary', 'text-white');
                document.getElementById('initials-btn').classList.remove('bg-primary', 'text-white');
                this.classList.add('bg-primary', 'text-white');
            });
            
            document.getElementById('initials-btn').addEventListener('click', function() {
                document.getElementById('signature-draw-container').classList.add('hidden');
                document.getElementById('signature-type-container').classList.remove('hidden');
                document.getElementById('signature-text').classList.add('hidden');
                document.getElementById('initials-text').classList.remove('hidden');
                document.getElementById('draw-signature').classList.remove('bg-primary', 'text-white');
                document.getElementById('type-signature').classList.remove('bg-primary', 'text-white');
                this.classList.add('bg-primary', 'text-white');
            });
            
            document.getElementById('clear-signature').addEventListener('click', function() {
                signaturePad.clear();
                document.getElementById('signature-text').value = '';
                document.getElementById('initials-text').value = '';
            });
            
            document.getElementById('save-signature').addEventListener('click', function() {
                 const drawContainerVisible = !document.getElementById('signature-draw-container').classList.contains('hidden');

                if (drawContainerVisible && !signaturePad.isEmpty()) {
                    const signatureData = signaturePad.toDataURL();
                    createSignatureAnnotation(signatureData, 'drawing');
                } else if (document.getElementById('initials-text').offsetParent !== null && document.getElementById('initials-text').value) { // Check if initials input is visible and has value
                     const initials = document.getElementById('initials-text').value;
                     createSignatureAnnotation(initials, 'initials'); // color taken from global
                 } else if (document.getElementById('signature-text').offsetParent !== null && document.getElementById('signature-text').value) { // Check if text input is visible and has value
                    const text = document.getElementById('signature-text').value;
                    createSignatureAnnotation(text, 'typed'); // color taken from global
                 } else if (!drawContainerVisible) {
                     alert('Please type your signature or initials.');
                 } else if (signaturePad.isEmpty()) {
                    alert('Please draw your signature.');
                 }
                 // Panel hiding is now handled globally
            });
            
            // Image tool panel
            document.getElementById('browse-images').addEventListener('click', function() {
                document.getElementById('image-input').click();
            });
            
            document.getElementById('image-input').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        createImageAnnotation(event.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // Highlight tool panel
            document.getElementById('highlight-opacity').addEventListener('input', function() {
                currentHighlightProperties.opacity = parseInt(this.value) / 100;
                updateSelectedAnnotation();
            });

            // Global click listener to handle deselecting annotations and hiding panels
             document.addEventListener('click', function(e) {
                const clickedAnnotation = e.target.closest('.annotation');
                const clickedPanel = e.target.closest('.tool-panel');
                const clickedToolButton = e.target.closest('.group > button[id$="-tool"]'); // Specifically target tool buttons
                const clickedSaveButton = e.target.closest('#save-pdf');

                // If the click is outside an annotation, panel, and *any* toolbar button (or save)
                if (!clickedAnnotation && !clickedPanel && !clickedToolButton && !clickedSaveButton) {
                     if (selectedAnnotation || activeTool) { // Only clear if something *was* selected/active
                           clearSelection(); // Hides panels
                           setActiveTool(null); // Deactivates tool
                      }
                 } else if (clickedAnnotation) {
                    // If clicking on editable text *within the currently selected annotation*
                     if (clickedAnnotation === selectedAnnotation && e.target.classList.contains('editable-text')) {
                        // It's a click *inside* the text box we already have selected, do nothing to panel
                        const annotation = annotations.find(a => a.id === clickedAnnotation.id);
                         if(annotation && annotation.type === 'text') {
                            // Make sure text tool is active and panel visible if somehow hidden
                             if (activeTool !== 'text') setActiveTool('text');
                            showToolPanel('text-tool-panel');
                         }
                    } else {
                         // Otherwise, select the clicked annotation (which might show a different panel)
                         selectAnnotation(clickedAnnotation);
                    }
                 }
                 // Clicks inside panels or on tool buttons are ignored here, they manage themselves

             }, true); // Use capture phase
        }

        function setSignatureColor(color) {
            currentSignatureColor = color;
            const colorMap = {
                black: '#000000',
                red: '#FF0000',
                blue: '#0000FF',
                green: '#008000'
            };
            signaturePad.penColor = colorMap[color];
            
            // Update selected color indicator
            document.querySelectorAll('#signature-draw-container .color-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.color === color) {
                    opt.classList.add('selected');
                }
            });
        }

        function setTypedSignatureColor(color) {
            currentTypedSignatureColor = color;
            
            // Update selected color indicator
            document.querySelectorAll('#signature-type-container .color-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.color === color) {
                    opt.classList.add('selected');
                }
            });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const typedArray = new Uint8Array(e.target.result);
                    loadPDF(typedArray);
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function loadPDF(data) {
            pdfjsLib.getDocument(data).promise.then(function(pdf) {
                pdfDoc = pdf;
                
                // Update page select dropdown
                const pageSelect = document.getElementById('page-select');
                pageSelect.innerHTML = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = 'Page ' + i;
                    pageSelect.appendChild(option);
                }
                
                // Render first page
                queueRenderPage(1);
            }).catch(function(error) {
                console.error('Error loading PDF:', error);
                alert('Error loading PDF. Please try another file.');
            });
        }

        function queueRenderPage(num) {
            if (pageRendering) {
                pageNumPending = num;
            } else {
                renderPage(num);
            }
        }

        function renderPage(num) {
            pageRendering = true;
            pageNum = num;
            
            // Update page select
            document.getElementById('page-select').value = num;
            
            pdfDoc.getPage(num).then(function(page) {
                const viewport = page.getViewport({ scale: scale });
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                const renderContext = {
                    canvasContext: ctx,
                    viewport: viewport
                };
                
                const renderTask = page.render(renderContext);
                
                renderTask.promise.then(function() {
                    pageRendering = false;
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                    
                    // Redraw annotations for this page
                    redrawAnnotations();
                });
            });
        }

        function renderBlankCanvas() {
            canvas.width = 800;
            canvas.height = 1000;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000000';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Upload a PDF to start editing', canvas.width / 2, canvas.height / 2);
        }

        function setActiveTool(tool) {
            // Deactivate previous tool button styling
             if(activeTool && document.getElementById(`${activeTool}-tool`)) {
                 document.getElementById(`${activeTool}-tool`).classList.remove('active-tool');
             }

            activeTool = tool; // Set the new tool

            // Activate new tool button styling
            if(activeTool && document.getElementById(`${activeTool}-tool`)) {
                 document.getElementById(`${activeTool}-tool`).classList.add('active-tool');
             }

             // Don't clear selection here - let selection logic handle it
             // clearSelection(); // OLD - remove this line
        }

        function showToolPanel(panelId) {
             // Hide all tool panels first
             document.querySelectorAll('.tool-panel').forEach(panel => {
                panel.style.display = 'none';
            });
            // Show the specific panel if its ID is provided and a tool is active
             if (panelId && activeTool) { // Ensure a tool is actually active
                 const panel = document.getElementById(panelId);
                 if (panel) panel.style.display = 'block';
            }
        }

        function addAnnotation(x, y) {
            if (!activeTool) return;
            
            const annotationId = 'annotation-' + Date.now();
            const annotationDiv = document.createElement('div');
            annotationDiv.className = 'annotation';
            annotationDiv.id = annotationId;
            annotationDiv.style.left = x + 'px';
            annotationDiv.style.top = y + 'px';
            
            // Set initial size based on tool
            let innerHtml = '';
             let initialHeight = 30; // Default height
             if (activeTool === 'text') {
                annotationDiv.style.width = '200px';
                 initialHeight = Math.max(30, currentTextProperties.fontSize * 1.5 + 5); // Calculate height based on font, min 30px + padding
                annotationDiv.style.height = initialHeight + 'px';
                
                // Create an editable div with auto-focus
                const editableDiv = document.createElement('div');
                editableDiv.className = 'editable-text';
                editableDiv.contentEditable = true;
                editableDiv.textContent = "Type here";
                editableDiv.style.fontFamily = currentTextProperties.fontFamily;
                editableDiv.style.fontSize = currentTextProperties.fontSize + 'px';
                editableDiv.style.color = 'black'; // Force black color on creation for visibility
                editableDiv.style.fontWeight = currentTextProperties.bold ? 'bold' : 'normal';
                editableDiv.style.fontStyle = currentTextProperties.italic ? 'italic' : 'normal';
                editableDiv.style.textDecoration = currentTextProperties.underline ? 'underline' : 'none';
                
                // Focus immediately
                setTimeout(() => {
                    editableDiv.focus();
                    // Move cursor to end
                    const range = document.createRange();
                    range.selectNodeContents(editableDiv);
                    range.collapse(false);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }, 0);
                
                // Update content when changed
                editableDiv.addEventListener('input', function() {
                    const annotation = annotations.find(a => a.id === annotationId);
                    if (annotation) {
                        annotation.content = editableDiv.textContent;
                    }
                });
                
                innerHtml = '';
                annotationDiv.appendChild(editableDiv);
                
            } else if (activeTool === 'highlight') {
                 annotationDiv.style.width = '100px';
                 initialHeight = 20; // Fixed height for highlight
                annotationDiv.style.height = initialHeight + 'px';
                 annotationDiv.style.backgroundColor = `rgba(255, 255, 0, ${currentHighlightProperties.opacity})`;
            } else if (activeTool === 'signature') {
                // Placeholder size, will be adjusted by signature logic later if needed
                annotationDiv.style.width = '200px';
                 initialHeight = 80; // Default for drawing signature
                 annotationDiv.style.height = initialHeight + 'px';
             } else if (activeTool === 'image') {
                 annotationDiv.style.width = '200px';
                 initialHeight = 150; // Default guess for image, will adjust on load
                 annotationDiv.style.height = initialHeight + 'px';
            }

            // Add delete button
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = function() { deleteAnnotation(annotationDiv); };
            annotationDiv.appendChild(deleteBtn);
            
            // Set up drag and resize
            setupDraggable(annotationDiv);
            
            document.getElementById('pdf-container').appendChild(annotationDiv);
            
            // Store annotation data
            const annotation = {
                id: annotationId,
                type: activeTool,
                page: pageNum,
                x: x,
                y: y,
                width: parseInt(annotationDiv.style.width),
                 height: initialHeight, // Store calculated initial height or default
                properties: activeTool === 'text' ? {...currentTextProperties} : 
                           activeTool === 'highlight' ? {...currentHighlightProperties} : null,
                content: activeTool === 'text' ? 'Type here' : null
                 // Signature/Image content added separately
            };
            
            annotations.push(annotation);
            
            // Select the new annotation (this will also handle showing the correct panel)
            selectAnnotation(annotationDiv);
        }

        function createSignatureAnnotation(content, type, color) { // color parameter may not be needed if global is used
             const signatureId = 'signature-' + Date.now();
             const signatureDiv = document.createElement('div');
             signatureDiv.className = 'annotation';
             signatureDiv.id = signatureId;

            let sigWidth = 200;
             let sigHeight = (type === 'drawing') ? 80 : 60;

            signatureDiv.style.width = sigWidth + 'px';
             signatureDiv.style.height = sigHeight + 'px';
            signatureDiv.style.cursor = 'move';
            
            // Center the signature on the canvas
            const rect = canvas.getBoundingClientRect();
            const x = rect.width / 2 - (sigWidth / 2);
            const y = rect.height / 2 - (sigHeight / 2);
            signatureDiv.style.left = x + 'px';
            signatureDiv.style.top = y + 'px';
            
             // Add content based on type
             if (type === 'drawing') {
                 signatureDiv.innerHTML = `<img src="${content}" style="width:100%; height:100%; object-fit: contain;" />`; // Added object-fit
             } else if (type === 'typed' || type === 'initials') {
                const font = document.getElementById('signature-font').value;
                 const textColor = currentTypedSignatureColor; // Use the global for typed
                const colorMap = {
                    black: '#000000', red: '#FF0000', blue: '#0000FF', green: '#008000', purple: '#800080'
                 };
                 signatureDiv.innerHTML = `<div style="font-family:${font}; color:${colorMap[textColor]}; font-size:${type === 'initials' ? '32px' : '24px'}; width:100%; height:100%; display:flex; align-items:center; justify-content:center; white-space: nowrap;">${content}</div>`;
             }

            // Add delete button consistently
             const deleteBtn = document.createElement('div');
             deleteBtn.className = 'delete-btn';
             deleteBtn.innerHTML = '&times;';
             deleteBtn.onclick = function(event) {
                event.stopPropagation(); // Prevent triggering other click listeners
                deleteAnnotation(signatureDiv);
             };
             signatureDiv.appendChild(deleteBtn);

            // Set up drag and resize
            setupDraggable(signatureDiv);
            
            document.getElementById('pdf-container').appendChild(signatureDiv);
            
            // Store annotation data
            const annotation = {
                id: signatureId,
                type: 'signature',
                signatureType: type,
                page: pageNum,
                x: x,
                y: y,
                 width: sigWidth, // Store initial width
                 height: sigHeight, // Store initial height
                content: content,
                 properties: (type === 'typed' || type === 'initials') ? {
                     font: document.getElementById('signature-font').value,
                     color: currentTypedSignatureColor // Store the typed color specifically
                } : null
            };
            
            annotations.push(annotation);
            
            // Select the new signature
            selectAnnotation(signatureDiv);
            
            // Clear signature inputs
             if (signaturePad) signaturePad.clear();
            document.getElementById('signature-text').value = '';
            document.getElementById('initials-text').value = '';

            // No longer hide panel globally here
        }

        function createImageAnnotation(imageData) {
            const imageId = 'image-' + Date.now();
            const imageDiv = document.createElement('div');
            imageDiv.className = 'annotation';
            imageDiv.id = imageId;
            
            // Set initial size and position
             let initialWidth = 200;
            imageDiv.style.width = initialWidth + 'px';
             imageDiv.style.height = 'auto'; // Let image load determine initial height
            
            // Center the image on the canvas
            const rect = canvas.getBoundingClientRect();
            const x = rect.width / 2 - (initialWidth / 2);
            const y = rect.height / 2 - 100; // Adjust initial Y placement maybe?
            imageDiv.style.left = x + 'px';
            imageDiv.style.top = y + 'px';
            
            // Add image content
            const img = document.createElement('img');
            img.src = imageData;
            img.style.width = '100%';
            img.style.height = 'auto'; // Maintain aspect ratio
             img.style.display = 'block'; // Prevent extra space below image

            imageDiv.innerHTML = '';
            imageDiv.appendChild(img);

            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '&times;';
             deleteBtn.onclick = function(event) {
                event.stopPropagation();
                 deleteAnnotation(imageDiv);
             };
            imageDiv.appendChild(deleteBtn);

             // Store annotation data (with placeholders until loaded)
             const annotation = {
                 id: imageId,
                 type: 'image',
                 page: pageNum,
                 x: x,
                 y: y,
                 width: initialWidth,
                 height: 'auto', // Update after load
                 content: imageData
             };

            // Set up image load logic BEFORE adding to DOM
            img.onload = function() {
                const aspectRatio = img.naturalWidth / img.naturalHeight;
                const initialHeight = initialWidth / aspectRatio;
                imageDiv.style.height = initialHeight + 'px';

                 // Update stored annotation height
                 const storedAnnotation = annotations.find(a => a.id === imageId);
                 if (storedAnnotation) {
                     storedAnnotation.height = initialHeight;
                     storedAnnotation.width = initialWidth; // Width is already set
                }

                 // Now add to DOM and setup draggable/observer *after* initial size is known
                 document.getElementById('pdf-container').appendChild(imageDiv);
                 setupDraggable(imageDiv); // Must be called after appending

                // Setup resize observer *after* imageDiv is in the DOM and has size
                 new ResizeObserver(() => {
                     const currentWidth = imageDiv.offsetWidth;
                    imageDiv.style.height = (currentWidth / aspectRatio) + 'px'; // Maintain aspect ratio on resize
                     // Update stored annotation width/height on resize
                     const anno = annotations.find(a => a.id === imageId);
                     if (anno) {
                        anno.width = currentWidth;
                         anno.height = imageDiv.offsetHeight;
                     }
                 }).observe(imageDiv);

                 // Select the new image
                 selectAnnotation(imageDiv);
            };
             img.onerror = function() {
                 console.error("Failed to load image for annotation");
                 // Maybe remove the annotation placeholder or show an error
            };

            // Only add annotation data, wait for onload to add element/setup drag/resize
             annotations.push(annotation);

            // Clear file input
            document.getElementById('image-input').value = '';
            // Global click handler will hide panel if necessary
        }

        function setupDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isResizing = false;
            
            element.onmousedown = dragMouseDown;
            
            function dragMouseDown(e) {
                e = e || window.event;
                 // Prevent triggering document click listener (for panel closing) or canvas click (for adding new items)
                 e.stopPropagation();
                e.preventDefault(); // Prevent text selection while dragging/resizing
                
                // Check if we're clicking on the resize handle
                const rect = element.getBoundingClientRect();
                const resizeHandleClicked = 
                    e.clientX >= rect.right - 15 && 
                    e.clientY >= rect.bottom - 15;
                
                if (resizeHandleClicked) {
                    isResizing = true;
                    element.style.cursor = 'nwse-resize';
                } else {
                    isResizing = false;
                    element.style.cursor = 'move'; // Ensure move cursor if not resizing
                }
                
                // Get the mouse cursor position at startup
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                document.onmouseup = closeDragElement;
                 document.onmousemove = elementDrag; // Moved inside mousedown
                 // e.stopPropagation(); // Already done above
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault(); // Prevent default browser drag behavior
                
                if (isResizing) {
                    // Calculate new width and height
                    const newWidth = element.offsetLeft + (e.clientX - pos3) + (pos3 - element.getBoundingClientRect().left) - element.offsetLeft;
                     const newHeight = element.offsetTop + (e.clientY - pos4) + (pos4 - element.getBoundingClientRect().top) - element.offsetTop;

                    const minWidth = 50; // Minimum dimensions
                    const minHeight = 20;

                    element.style.width = Math.max(minWidth, newWidth) + 'px';
                     element.style.height = Math.max(minHeight, newHeight) + 'px'; // Use calculated height, apply min

                    // Maintain aspect ratio for images during resize
                    const img = element.querySelector('img');
                     if (img) {
                         const aspectRatio = img.naturalWidth / img.naturalHeight;
                         const currentWidth = element.offsetWidth;
                         element.style.height = (currentWidth / aspectRatio) + 'px'; // Adjust height based on width
                     }

                } else {
                    // Calculate the new cursor position
                    pos1 = pos3 - e.clientX;
                    pos2 = pos4 - e.clientY;
                    pos3 = e.clientX;
                    pos4 = e.clientY;
                    
                    // Set the element's new position
                    element.style.top = (element.offsetTop - pos2) + "px";
                    element.style.left = (element.offsetLeft - pos1) + "px";
                }
                
                // Update annotation position/size in the array (debounce might be good here for performance)
                const annotation = annotations.find(a => a.id === element.id);
                if (annotation) {
                    annotation.x = element.offsetLeft;
                    annotation.y = element.offsetTop;
                    annotation.width = element.offsetWidth;
                     annotation.height = element.offsetHeight; // Use offsetHeight after styles applied
                }
            }
            
            function closeDragElement() {
                // Stop moving/resizing when mouse button is released
                document.onmouseup = null;
                document.onmousemove = null;
                 element.style.cursor = 'move'; // Reset cursor
                 isResizing = false; // Ensure resizing state is reset
            }
        }

        function selectAnnotation(annotationElement) {
             if (selectedAnnotation === annotationElement) {
                 // If clicking the already selected annotation, just ensure its panel is visible
                  const annotation = annotations.find(a => a.id === annotationElement.id);
                  if (annotation && annotation.type === 'text') showToolPanel('text-tool-panel');
                  else if (annotation && annotation.type === 'highlight') showToolPanel('highlight-tool-panel');
                  // Signature and image panels handled by tool activation usually
                 return; // Do nothing else if clicking the same selected annotation
             }

            // Clear previous selection (will also hide old panel)
            clearSelection();
            
            // Set new selection
            annotationElement.classList.add('selected');
            selectedAnnotation = annotationElement;
            
            // Update properties panel based on the newly selected annotation
            const annotation = annotations.find(a => a.id === annotationElement.id);
            if (!annotation) return;
            
             // Determine which panel to show
             let panelToShow = null;
             if (annotation.type === 'text') panelToShow = 'text-tool-panel';
             else if (annotation.type === 'highlight') panelToShow = 'highlight-tool-panel';
             // Add other types here if needed, like signature or image specific panels
             // else if (annotation.type === 'signature') panelToShow = 'signature-tool-panel';
             // else if (annotation.type === 'image') panelToShow = 'image-tool-panel';

             if(panelToShow){
                 showToolPanel(panelToShow); // showToolPanel now hides others first
                 // Update the panel controls with the properties of the selected annotation
                if (annotation.type === 'text') {
                     document.querySelector(`#text-tool-panel .font-option[style*="${annotation.properties.fontFamily}"]`)?.click();
                    document.getElementById('text-size').value = annotation.properties.fontSize;
                    document.querySelectorAll('#text-tool-panel .color-option').forEach(opt => {
                        opt.classList.toggle('selected', opt.dataset.color === annotation.properties.color);
                    });
                     document.getElementById('bold-text').classList.toggle('bg-gray-200', annotation.properties.bold);
                     document.getElementById('italic-text').classList.toggle('bg-gray-200', annotation.properties.italic);
                     document.getElementById('underline-text').classList.toggle('bg-gray-200', annotation.properties.underline);
                    currentTextProperties = {...annotation.properties}; // Sync global state
                 } else if (annotation.type === 'highlight') {
                    document.querySelectorAll('#highlight-tool-panel .color-option').forEach(opt => {
                         opt.classList.toggle('selected', opt.dataset.color === annotation.properties.color);
                    });
                    document.getElementById('highlight-opacity').value = annotation.properties.opacity * 100;
                    currentHighlightProperties = {...annotation.properties}; // Sync global state
                 }
             }
        }

        function clearSelection() {
            if(selectedAnnotation) { // Only remove class if something was selected
                 selectedAnnotation.classList.remove('selected');
             }
            selectedAnnotation = null;
            // Hide all tool panels when clearing selection
             document.querySelectorAll('.tool-panel').forEach(panel => panel.style.display = 'none');
        }

        function updateSelectedAnnotation() {
            if (!selectedAnnotation) return;
            
            const annotation = annotations.find(a => a.id === selectedAnnotation.id);
            if (!annotation) return;
            
            if (annotation.type === 'text') {
                // Update the properties in the annotation object
                annotation.properties = {...currentTextProperties};
                
                // Update the visual appearance
                const editableDiv = selectedAnnotation.querySelector('.editable-text');
                if (editableDiv) {
                    const fontWeight = currentTextProperties.bold ? 'bold' : 'normal';
                    const fontStyle = currentTextProperties.italic ? 'italic' : 'normal';
                    const textDecoration = currentTextProperties.underline ? 'underline' : 'none';
                    
                    editableDiv.style.fontFamily = currentTextProperties.fontFamily;
                    editableDiv.style.fontSize = currentTextProperties.fontSize + 'px';
                    editableDiv.style.color = currentTextProperties.color;
                    editableDiv.style.fontWeight = fontWeight;
                    editableDiv.style.fontStyle = fontStyle;
                    editableDiv.style.textDecoration = textDecoration;

                     // Adjust height dynamically based on content? Could be complex.
                     // For now, rely on manual resize.
                     // editableDiv.style.height = 'auto';
                    // editableDiv.style.height = editableDiv.scrollHeight + 'px';
                }
                
            } else if (annotation.type === 'highlight') {
                // Update the properties in the annotation object
                annotation.properties = {...currentHighlightProperties};
                
                // Update the visual appearance
                 let colorRgba = 'rgba(255, 255, 0, 0.5)'; // Default
                 switch(currentHighlightProperties.color) {
                    case 'green': colorRgba = `rgba(0, 255, 0, ${currentHighlightProperties.opacity})`; break;
                    case 'blue': colorRgba = `rgba(0, 0, 255, ${currentHighlightProperties.opacity})`; break;
                    case 'pink': colorRgba = `rgba(255, 192, 203, ${currentHighlightProperties.opacity})`; break;
                    case 'purple': colorRgba = `rgba(128, 0, 128, ${currentHighlightProperties.opacity})`; break;
                     case 'yellow': colorRgba = `rgba(255, 255, 0, ${currentHighlightProperties.opacity})`; break;
                }
                selectedAnnotation.style.backgroundColor = colorRgba;
            }
        }

        function deleteAnnotation(element) {
            // Stop event propagation is handled in the onclick handler now
            // event.stopPropagation();
            
            // Remove from DOM
            element.remove();
            
            // Remove from annotations array
            annotations = annotations.filter(a => a.id !== element.id);
            
            // Clear selection if this was the selected annotation
            if (selectedAnnotation && selectedAnnotation.id === element.id) {
                clearSelection();
                 setActiveTool(null); // Also deactivate tool if the item was deleted
            }
        }

        function redrawAnnotations() {
            // First remove all existing annotation elements
            document.querySelectorAll('.annotation').forEach(el => el.remove());
            
            // Then recreate them for the current page
            annotations.forEach(annotation => {
                // Only show annotations for current page
                if (annotation.page !== pageNum) return;
                
                const annotationDiv = document.createElement('div');
                annotationDiv.className = 'annotation';
                annotationDiv.id = annotation.id;
                annotationDiv.style.left = annotation.x + 'px';
                annotationDiv.style.top = annotation.y + 'px';
                 annotationDiv.style.width = annotation.width + 'px'; // Use stored width
                 // Use stored height, handling 'auto' maybe? Let browser handle or recalculate if needed
                 annotationDiv.style.height = (typeof annotation.height === 'number' && annotation.height > 0) ? annotation.height + 'px' : (annotation.type === 'image' ? 'auto' : '30px'); // Fallback height
                
                if (annotation.type === 'text') {
                    console.log(`Redrawing text annotation ${annotation.id}, content: "${annotation.content}"`); // DIAGNOSTIC
                    const fontWeight = annotation.properties.bold ? 'bold' : 'normal';
                    const fontStyle = annotation.properties.italic ? 'italic' : 'normal';
                    const textDecoration = annotation.properties.underline ? 'underline' : 'none';
                    
                    const editableDiv = document.createElement('div');
                     console.log(' > editableDiv created'); // DIAGNOSTIC
                    editableDiv.className = 'editable-text';
                    editableDiv.contentEditable = true;
                    editableDiv.textContent = annotation.content || 'Type here';
                    console.log(` > editableDiv.textContent set to: "${editableDiv.textContent}"`); // DIAGNOSTIC
                    editableDiv.style.fontFamily = annotation.properties.fontFamily;
                    editableDiv.style.fontSize = annotation.properties.fontSize + 'px';
                     editableDiv.style.color = annotation.properties.color || 'black'; // Ensure color default on redraw too
                     console.log(` > editableDiv.style.color set to: "${editableDiv.style.color}"`); // DIAGNOSTIC
                    editableDiv.style.fontWeight = fontWeight;
                    editableDiv.style.fontStyle = fontStyle;
                    editableDiv.style.textDecoration = textDecoration;
                    
                    // Update content when changed
                    editableDiv.addEventListener('input', function() {
                        const anno = annotations.find(a => a.id === annotation.id);
                        if (anno) {
                            anno.content = editableDiv.textContent;
                        }
                    });
                    
                    annotationDiv.appendChild(editableDiv);
                    console.log(' > editableDiv appended'); // DIAGNOSTIC
                } 
                else if (annotation.type === 'highlight') {
                     const opacity = annotation.properties.opacity || 0.5;
                     let colorRgba = `rgba(255, 255, 0, ${opacity})`; // Default yellow
                     switch (annotation.properties.color) {
                         case 'green': colorRgba = `rgba(0, 255, 0, ${opacity})`; break;
                         case 'blue': colorRgba = `rgba(0, 0, 255, ${opacity})`; break;
                         case 'pink': colorRgba = `rgba(255, 192, 203, ${opacity})`; break;
                         case 'purple': colorRgba = `rgba(128, 0, 128, ${opacity})`; break;
                     }
                    annotationDiv.style.backgroundColor = colorRgba;
                }
                else if (annotation.type === 'signature') {
                    if (annotation.signatureType === 'drawing') {
                         annotationDiv.innerHTML = `<img src="${annotation.content}" style="width:100%; height:100%; object-fit: contain;" />`; // contain added
                    } else {
                        const colorMap = { black: '#000000', red: '#FF0000', blue: '#0000FF', green: '#008000', purple: '#800080' };
                        const color = annotation.properties?.color || 'black';
                         annotationDiv.innerHTML = `<div style="font-family:${annotation.properties?.font || 'Arial'}; 
                                                color:${colorMap[color]}; 
                                                font-size:${annotation.signatureType === 'initials' ? '32px' : '24px'}; 
                                                width:100%; height:100%;
                                                display:flex; align-items:center; justify-content:center;
                                                 white-space: nowrap; overflow: hidden;">${annotation.content}</div>`; // Added overflow/nowrap
                    }
                     // Add delete button after innerHTML is set
                     const deleteBtn = document.createElement('div');
                     deleteBtn.className = 'delete-btn';
                     deleteBtn.innerHTML = '&times;';
                     deleteBtn.onclick = function(event) { event.stopPropagation(); deleteAnnotation(annotationDiv); };
                     annotationDiv.appendChild(deleteBtn);

                }
                else if (annotation.type === 'image') {
                    const img = document.createElement('img');
                    img.src = annotation.content;
                    img.style.width = '100%';
                    img.style.height = 'auto';
                     img.style.display = 'block';
                    
                    annotationDiv.innerHTML = ''; // Clear potential old content
                    annotationDiv.appendChild(img);

                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '&times;';
                     deleteBtn.onclick = function(event) { event.stopPropagation(); deleteAnnotation(annotationDiv); };
                    annotationDiv.appendChild(deleteBtn);

                    // We might need the resize observer setup here too if 'auto' height causes issues on redraw
                     img.onload = () => {
                          if (annotationDiv.style.height === 'auto') { // If still auto, calculate from aspect ratio
                              const aspectRatio = img.naturalWidth / img.naturalHeight;
                              annotationDiv.style.height = (annotationDiv.offsetWidth / aspectRatio) + 'px';
                              // Update stored height if it changed from 'auto'
                              annotation.height = annotationDiv.offsetHeight;
                          }
                     }
                }
                
                // Set up drag and resize AFTER element is configured
                setupDraggable(annotationDiv);
                
                document.getElementById('pdf-container').appendChild(annotationDiv);
                
                // Re-select if this was the selected annotation when page was changed
                if (selectedAnnotation && selectedAnnotation.id === annotation.id) {
                     // Re-apply selected class visually, but don't re-trigger full select logic (panel etc)
                     annotationDiv.classList.add('selected');
                     // Re-assign the DOM element reference to the new one
                    selectedAnnotation = annotationDiv;
                }
            });
        }

        async function savePDF() {
            if (!pdfDoc) {
                alert('No PDF loaded to save.');
                return;
            }

            // Show saving indicator
            const saveBtn = document.getElementById('save-pdf');
            const originalText = saveBtn.innerHTML;
            saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            saveBtn.disabled = true;

            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    unit: 'pt',
                    compress: true
                });

                // Helper to load images
                const loadImage = (src) => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                         img.onerror = (err) => { console.error("Image load error:", src, err); reject(err); }; // Log errors
                        img.src = src;
                    });
                };

                // Process pages sequentially
                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    console.log(`Processing page ${i}`);
                    const page = await pdfDoc.getPage(i);
                    const viewport = page.getViewport({ scale: 1.0 }); // Save at scale 1.0
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');

                    tempCanvas.width = viewport.width;
                    tempCanvas.height = viewport.height;

                    // Render PDF page
                    const renderContext = {
                        canvasContext: tempCtx,
                        viewport: viewport
                    };
                    await page.render(renderContext).promise;
                    console.log(` Page ${i} rendered`);

                    // Prepare promises for drawing annotations
                    const pageAnnotations = annotations.filter(a => a.page === i);
                     console.log(` Found ${pageAnnotations.length} annotations for page ${i}`);
                    const drawingPromises = [];

                    pageAnnotations.forEach(annotation => {
                        // Adjust coordinates and dimensions from display scale to save scale (1.0)
                         // Use annotation.width/height directly if they are numbers, otherwise recalculate? Needs care.
                         // Assuming annotation.x/y/width/height were stored based on the display 'scale'
                        const scaledX = annotation.x / scale;
                        const scaledY = annotation.y / scale;
                         const scaledWidth = annotation.width / scale;
                        let scaledHeight = (typeof annotation.height === 'number') ? annotation.height / scale : 0; // Initial default, adjust per type
                         const scaledFontSize = (annotation.properties?.fontSize || 14) / scale; // Use default if needed

                         console.log(` Drawing annotation ${annotation.id} (type: ${annotation.type}) at [${scaledX}, ${scaledY}], size [${scaledWidth}, ${scaledHeight}]`);


                        if (annotation.type === 'text') {
                            // Ensure scaledHeight is calculated for text based on lines and font size for saving
                             const lines = (annotation.content || '').split('\n');
                             const lineHeight = scaledFontSize * 1.2;
                             scaledHeight = lines.length * lineHeight; // Approximate height for drawing bounding box (optional)


                            drawingPromises.push(new Promise((resolve) => {
                                tempCtx.save();
                                const fontWeight = annotation.properties.bold ? 'bold ' : '';
                                const fontStyle = annotation.properties.italic ? 'italic ' : '';
                                const fontSize = scaledFontSize;
                                const fontFamily = annotation.properties.fontFamily || 'Arial';
                                tempCtx.font = `${fontWeight}${fontStyle}${fontSize}px ${fontFamily}`;
                                tempCtx.fillStyle = annotation.properties.color || 'black';
                                 tempCtx.textBaseline = 'top'; // Draw from top-left

                                let currentY = scaledY;
                                lines.forEach(line => {
                                    tempCtx.fillText(line, scaledX, currentY);

                                    if (annotation.properties.underline) {
                                        tempCtx.beginPath();
                                        tempCtx.strokeStyle = tempCtx.fillStyle;
                                         tempCtx.lineWidth = Math.max(1, 1 / scale); // Ensure minimum 1px
                                         // Underline position needs careful adjustment based on font metrics - approximation:
                                         tempCtx.moveTo(scaledX, currentY + fontSize + 1/scale );
                                         tempCtx.lineTo(scaledX + tempCtx.measureText(line).width, currentY + fontSize + 1/scale);
                                        tempCtx.stroke();
                                    }
                                    currentY += lineHeight;
                                });
                                tempCtx.restore();
                                resolve();
                            }));
                        }
                        else if (annotation.type === 'highlight') {
                             scaledHeight = (typeof annotation.height === 'number') ? annotation.height / scale : 20 / scale; // Default highlight height scaled
                            drawingPromises.push(new Promise((resolve) => {
                                tempCtx.save();
                                const opacity = annotation.properties.opacity || 0.5;
                                let colorRgba = `rgba(255, 255, 0, ${opacity})`; // Default yellow
                                switch (annotation.properties.color) {
                                     case 'green': colorRgba = `rgba(0, 255, 0, ${opacity})`; break;
                                     case 'blue': colorRgba = `rgba(0, 0, 255, ${opacity})`; break;
                                     case 'pink': colorRgba = `rgba(255, 192, 203, ${opacity})`; break;
                                     case 'purple': colorRgba = `rgba(128, 0, 128, ${opacity})`; break;
                                     // yellow is default
                                }
                                tempCtx.fillStyle = colorRgba;
                                tempCtx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                                tempCtx.restore();
                                resolve();
                            }));
                        }
                         else if (annotation.type === 'signature' && annotation.signatureType === 'drawing') {
                            scaledHeight = (typeof annotation.height === 'number' && annotation.height > 0) ? annotation.height / scale : 80 / scale; // Drawing default
                            drawingPromises.push(
                                 loadImage(annotation.content).then(img => {
                                     console.log(` Drawing image/signature ${annotation.id}`);
                                     tempCtx.drawImage(img, scaledX, scaledY, scaledWidth, scaledHeight);
                                }).catch(err => console.error(` Error loading signature image ${annotation.id}:`, err))
                             );
                         }
                         else if (annotation.type === 'image') {
                             // Height calculation should happen within loadImage if still 'auto'
                             drawingPromises.push(
                                 loadImage(annotation.content).then(img => {
                                    let drawWidth = scaledWidth;
                                     let drawHeight = scaledHeight;
                                     if (drawHeight === 0) { // Was 'auto', calc now
                                         const aspectRatio = img.naturalWidth / img.naturalHeight;
                                         drawHeight = drawWidth / aspectRatio;
                                        if (!isFinite(drawHeight)) drawHeight = 150/scale; // Fallback if calc fails
                                     }
                                     console.log(` Drawing image ${annotation.id}`);
                                     tempCtx.drawImage(img, scaledX, scaledY, drawWidth, drawHeight);
                                }).catch(err => console.error(` Error loading image ${annotation.id}:`, err))
                             );
                         }
                         else if (annotation.type === 'signature' && (annotation.signatureType === 'typed' || annotation.signatureType === 'initials')) {
                            scaledHeight = (typeof annotation.height === 'number' && annotation.height > 0) ? annotation.height / scale : 60 / scale; // Typed/initial default
                            drawingPromises.push(new Promise((resolve) => {
                                tempCtx.save();
                                const colorMap = { black: '#000000', red: '#FF0000', blue: '#0000FF', green: '#008000', purple: '#800080' };
                                const color = annotation.properties?.color || 'black';
                                const fontSize = scaledFontSize; // Use calculated size
                                const fontFamily = annotation.properties?.font || 'Arial';

                                tempCtx.font = `${fontSize}px ${fontFamily}`;
                                tempCtx.fillStyle = colorMap[color] || '#000000';
                                 tempCtx.textAlign = 'center';
                                 tempCtx.textBaseline = 'middle';
                                 tempCtx.fillText(annotation.content, scaledX + scaledWidth / 2, scaledY + scaledHeight / 2);
                                tempCtx.restore();
                                resolve();
                            }));
                        }
                    });

                    // Wait for all annotations on the current page to be drawn
                     console.log(` Awaiting ${drawingPromises.length} drawing promises for page ${i}...`);
                    await Promise.all(drawingPromises);
                     console.log(` Drawings complete for page ${i}`);

                    // Add the rendered page (with annotations) to the PDF
                    const imgData = tempCanvas.toDataURL('image/jpeg', 0.9);
                    if (i > 1) {
                        doc.addPage([viewport.width, viewport.height], 'portrait');
                    }
                    doc.addImage(imgData, 'JPEG', 0, 0, viewport.width, viewport.height);
                     console.log(` Page ${i} added to doc.`);

                } // End page loop

                // Save the final PDF
                 console.log('Saving PDF...');
                doc.save('edited-document.pdf');
                 console.log('PDF save initiated.');

            } catch (error) {
                console.error('Error during PDF saving:', error);
                alert('An error occurred while saving the PDF. Please try again.');
            } finally {
                // Restore save button state regardless of success or failure
                saveBtn.innerHTML = originalText;
                saveBtn.disabled = false;
                 console.log('Save button state restored.');
            }
        }

        // Make functions available globally for event handlers
        window.deleteAnnotation = deleteAnnotation;
        window.setSignatureColor = setSignatureColor;
        window.setTypedSignatureColor = setTypedSignatureColor;
    </script>
</body>
</html>
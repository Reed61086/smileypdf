<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PDF Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/signature_pad/1.5.3/signature_pad.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5',
                        secondary: '#6B7280',
                        accent: '#10B981',
                        danger: '#EF4444',
                    }
                }
            }
        }
    </script>
    <style>
        #pdf-render {
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin: 0 auto;
            position: relative;
            overflow: hidden; /* Keep hidden for container, annotation overflow should be handled */
        }
        .canvas-container {
            position: relative;
            margin: 0 auto;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .annotation {
            position: absolute;
            cursor: move;
            resize: both;
            overflow: visible; /* Allow text overflow */
            min-width: 50px;
            min-height: 20px;
            border: 1px dashed transparent;
            z-index: 5; /* Ensure annotations are above the canvas */
        }
        .annotation:hover {
            border-color: #4F46E5;
        }
        .annotation.selected {
            border: 1px dashed #4F46E5;
            background-color: rgba(79, 70, 229, 0.1);
        }
        .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background-color: #EF4444;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .annotation:hover .delete-btn {
            opacity: 1;
        }
        #signature-pad {
            border: 1px solid #e5e7eb;
            background-color: white;
            touch-action: none;
            width: 100%;
        }
        .tool-panel {
            position: absolute;
            left: 70px;
            top: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 10px;
            z-index: 100;
            width: 250px;
            display: none;
        }
        .color-option {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            margin: 3px;
            border: 2px solid white;
        }
        .color-option.selected {
            border-color: #4F46E5;
            transform: scale(1.1);
        }
        .font-option {
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        .font-option.selected {
            background-color: #E5E7EB;
            font-weight: bold;
        }
        .tooltip-text {
            position: absolute;
            left: 60px;
            background-color: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            white-space: nowrap;
            z-index: 1000;
        }
        .group:hover .tooltip-text {
            opacity: 1;
        }
        #signature-type-container {
            margin-top: 10px;
        }
        #file-input {
            display: none;
        }
        #initials-text {
            display: none;
        }
        .active-tool {
            background-color: #4F46E5 !important;
            color: white !important;
        }
        /* Resize handle styling */
        .annotation::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: #4F46E5;
            border-radius: 2px;
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .annotation:hover::after {
            opacity: 1;
        }
        /* Editable text area */
        .editable-text {
            min-height: 20px; /* Ensure it's at least clickable */
            width: 100%; /* Take full width of parent */
            height: 100%; /* Take full height of parent */
            outline: none;
            padding: 2px;
            cursor: text;
            box-sizing: border-box; /* Include padding in size */
            overflow-wrap: break-word; /* Allow long words to break */
            word-wrap: break-word; /* Older browser support */
            white-space: pre-wrap; /* Preserve whitespace and wrap */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="flex h-screen overflow-hidden">
        <!-- Left Toolbar -->
        <div class="w-16 bg-white shadow-md flex flex-col items-center py-4 space-y-6">
            <!-- Upload PDF Button -->
            <div class="group relative">
                <button id="upload-btn" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-file-upload text-gray-700"></i>
                </button>
                <input type="file" id="file-input" accept=".pdf">
                <span class="tooltip-text">Upload PDF</span>
            </div>

            <!-- Text Tool -->
            <div class="group relative">
                <button id="text-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-font text-gray-700"></i>
                </button>
                <span class="tooltip-text">Text Tool</span>
            </div>

            <!-- Signature Tool -->
            <div class="group relative">
                <button id="signature-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-signature text-gray-700"></i>
                </button>
                <span class="tooltip-text">Signature/Initials</span>
            </div>

            <!-- Image Tool -->
            <div class="group relative">
                <button id="image-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-image text-gray-700"></i>
                </button>
                <span class="tooltip-text">Image Tool</span>
            </div>

            <!-- Highlight Tool -->
            <div class="group relative">
                <button id="highlight-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-highlighter text-gray-700"></i>
                </button>
                <span class="tooltip-text">Highlight Tool</span>
            </div>

            <!-- Save Button -->
            <div class="group relative mt-auto">
                <button id="save-pdf" class="w-12 h-12 rounded-lg flex items-center justify-center bg-primary hover:bg-purple-700 transition text-white">
                    <i class="fas fa-save"></i>
                </button>
                <span class="tooltip-text">Save PDF</span>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Top Bar -->
            <div class="bg-white shadow-sm py-3 px-4 flex items-center justify-between">
                <h1 class="text-xl font-semibold text-gray-800">PDF Editor</h1>
                <div class="flex items-center space-x-4">
                    <div>
                        <span class="text-gray-600 mr-2">Page:</span>
                        <select id="page-select" class="border rounded px-2 py-1">
                            <!-- Pages will be added dynamically -->
                        </select>
                    </div>
                    <button id="zoom-in" class="w-8 h-8 rounded flex items-center justify-center hover:bg-gray-100">
                        <i class="fas fa-search-plus text-gray-600"></i>
                    </button>
                    <button id="zoom-out" class="w-8 h-8 rounded flex items-center justify-center hover:bg-gray-100">
                        <i class="fas fa-search-minus text-gray-600"></i>
                    </button>
                </div>
            </div>

            <!-- PDF Viewer -->
            <div class="flex-1 overflow-auto p-6 bg-gray-50" id="pdf-viewer">
                <div id="pdf-container" class="relative mx-auto">
                    <div id="pdf-render" class="canvas-container">
                        <canvas id="pdf-canvas"></canvas>
                        <!-- Annotations will be added here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Text Tool Panel -->
        <div id="text-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Text Properties</h3>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Font Family</label>
                <div class="flex flex-wrap">
                    <div class="font-option selected" style="font-family: 'Arial'">Arial</div>
                    <div class="font-option" style="font-family: 'Times New Roman'">Times</div>
                    <div class="font-option" style="font-family: 'Courier New'">Courier</div>
                    <div class="font-option" style="font-family: 'Georgia'">Georgia</div>
                    <div class="font-option" style="font-family: 'Verdana'">Verdana</div>
                    <div class="font-option" style="font-family: 'Comic Sans MS'">Comic</div>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Font Size</label>
                <input type="range" id="text-size" min="8" max="72" value="14" class="w-full">
                <div class="flex justify-between text-xs text-gray-600">
                    <span>8</span>
                    <span>20</span>
                    <span>32</span>
                    <span>44</span>
                    <span>56</span>
                    <span>72</span>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Text Color</label>
                <div class="flex flex-wrap">
                    <div class="color-option bg-black selected" data-color="black"></div>
                    <div class="color-option bg-red-500" data-color="red"></div>
                    <div class="color-option bg-blue-500" data-color="blue"></div>
                    <div class="color-option bg-green-500" data-color="green"></div>
                    <div class="color-option bg-yellow-500" data-color="yellow"></div>
                    <div class="color-option bg-purple-500" data-color="purple"></div>
                    <div class="color-option bg-pink-500" data-color="pink"></div>
                    <div class="color-option bg-gray-500" data-color="gray"></div>
                </div>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Bold/Italic/Underline</label>
                <div class="flex">
                    <button id="bold-text" class="px-3 py-1 border rounded-l hover:bg-gray-100">
                        <i class="fas fa-bold"></i>
                    </button>
                    <button id="italic-text" class="px-3 py-1 border-t border-b hover:bg-gray-100">
                        <i class="fas fa-italic"></i>
                    </button>
                    <button id="underline-text" class="px-3 py-1 border rounded-r hover:bg-gray-100">
                        <i class="fas fa-underline"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Signature Tool Panel -->
        <div id="signature-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Add Signature/Initials</h3>
            <div class="mb-4">
                <div class="flex space-x-3 mb-3">
                    <button id="draw-signature" class="flex-1 py-2 bg-primary text-white rounded hover:bg-purple-700">Draw</button>
                    <button id="type-signature" class="flex-1 py-2 bg-gray-100 rounded hover:bg-gray-200">Type</button>
                    <button id="initials-btn" class="flex-1 py-2 bg-gray-100 rounded hover:bg-gray-200">Initials</button>
                </div>
                <div id="signature-draw-container" class="border rounded mb-3">
                    <div class="flex justify-between items-center mb-2 px-2 pt-1">
                        <label class="text-sm font-medium text-gray-700">Pen Color:</label>
                        <div class="flex">
                            <div class="color-option bg-black selected" data-color="black" onclick="setSignatureColor('black')"></div>
                            <div class="color-option bg-red-500" data-color="red" onclick="setSignatureColor('red')"></div>
                            <div class="color-option bg-blue-500" data-color="blue" onclick="setSignatureColor('blue')"></div>
                            <div class="color-option bg-green-500" data-color="green" onclick="setSignatureColor('green')"></div>
                        </div>
                    </div>
                    <canvas id="signature-pad" height="150"></canvas>
                </div>
                <div id="signature-type-container" class="mb-3 hidden">
                    <input type="text" id="signature-text" placeholder="Type your name" class="w-full border rounded px-3 py-2">
                    <input type="text" id="initials-text" placeholder="Type your initials" class="w-full border rounded px-3 py-2 mt-2 hidden">
                    <div class="flex mt-2 items-center">
                        <select id="signature-font" class="border rounded px-2 py-1 flex-1 mr-2">
                            <option value="'Brush Script MT', cursive">Brush Script</option>
                            <option value="'Dancing Script', cursive">Dancing Script</option>
                            <option value="'Parisienne', cursive">Parisienne</option>
                            <option value="'Great Vibes', cursive">Great Vibes</option>
                        </select>
                        <div class="flex">
                            <div class="color-option bg-black selected" data-color="black" onclick="setTypedSignatureColor('black')"></div>
                            <div class="color-option bg-red-500" data-color="red" onclick="setTypedSignatureColor('red')"></div>
                            <div class="color-option bg-blue-500" data-color="blue" onclick="setTypedSignatureColor('blue')"></div>
                            <div class="color-option bg-green-500" data-color="green" onclick="setTypedSignatureColor('green')"></div>
                            <div class="color-option bg-purple-500" data-color="purple" onclick="setTypedSignatureColor('purple')"></div>
                        </div>
                    </div>
                </div>
                <div class="flex justify-between">
                    <button id="clear-signature" class="px-3 py-2 bg-gray-200 rounded hover:bg-gray-300">
                        Clear
                    </button>
                    <button id="save-signature" class="px-3 py-2 bg-primary text-white rounded hover:bg-purple-700">
                        Save & Add
                    </button>
                </div>
            </div>
        </div>

        <!-- Image Tool Panel -->
        <div id="image-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Add Image</h3>
            <div class="mb-4">
                <div id="image-drop-zone" class="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center cursor-pointer hover:border-primary hover:bg-indigo-50 transition-colors">
                    <i class="fas fa-image text-4xl text-gray-400 mb-2"></i>
                    <p class="text-sm text-gray-500">Drag & drop image here or</p>
                    <button id="browse-images" type="button" class="mt-2 px-4 py-2 bg-primary text-white rounded hover:bg-purple-700">
                        Browse Files
                    </button>
                    <input type="file" id="image-input" accept="image/*" class="hidden">
                </div>
            </div>
        </div>

        <!-- Highlight Tool Panel -->
        <div id="highlight-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Highlight Properties</h3>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Highlight Color</label>
                <div class="flex flex-wrap">
                    <!-- Updated highlight colors to match Tailwind better -->
                    <div class="color-option selected" data-color="yellow" style="background-color: rgba(253, 224, 71, 0.5);"></div>
                    <div class="color-option" data-color="green" style="background-color: rgba(75, 181, 67, 0.5);"></div>
                    <div class="color-option" data-color="blue" style="background-color: rgba(59, 130, 246, 0.5);"></div>
                    <div class="color-option" data-color="pink" style="background-color: rgba(236, 72, 153, 0.5);"></div>
                    <div class="color-option" data-color="purple" style="background-color: rgba(139, 92, 246, 0.5);"></div>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Opacity</label>
                <input type="range" id="highlight-opacity" min="30" max="100" value="50" class="w-full">
                <div class="flex justify-between text-xs text-gray-600">
                    <span>30%</span>
                    <span>65%</span>
                    <span>100%</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // PDF.js setup
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        // --- Global Variables ---
        const colorMap = { // Map color names used in UI to hex for drawing consistency
            black: '#000000', red: '#EF4444', blue: '#3B82F6', green: '#10B981',
            yellow: '#F59E0B', purple: '#8B5CF6', pink: '#EC4899', gray: '#6B7280'
        };
        const highlightColorMap = { // Map highlight color names to RGBA strings
             yellow: 'rgba(253, 224, 71, ##OPACITY##)', // yellow-400
             green: 'rgba(75, 181, 67, ##OPACITY##)',  // green-500 approx
             blue: 'rgba(59, 130, 246, ##OPACITY##)',   // blue-500
             pink: 'rgba(236, 72, 153, ##OPACITY##)',   // pink-500
             purple: 'rgba(139, 92, 246, ##OPACITY##)'  // purple-500
         };

        let pdfDoc = null,
            pageNum = 1,
            pageRendering = false,
            pageNumPending = null,
            scale = 1.0,
            canvas = document.getElementById('pdf-canvas'),
            ctx = canvas.getContext('2d'),
            activeTool = null,
            annotations = [], // Stores { id, type, page, x, y, width, height, properties, content, signatureType? }
            selectedAnnotation = null, // Stores the DOM element
            signaturePad = null;

        // Default states for tools
        let currentSignatureColor = 'black'; // For drawing pad
        let currentTypedSignatureColor = 'black'; // For typed text
        let currentTextProperties = {
            fontFamily: 'Arial',
            fontSize: 14,
            color: 'black', // Store the color name/key used in UI/colorMap
            bold: false,
            italic: false,
            underline: false
        };
        let currentHighlightProperties = {
            color: 'yellow', // Corresponds to keys in highlightColorMap
            opacity: 0.5
        };

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            initializeSignaturePad();
            window.addEventListener('resize', resizeSignatureCanvas);
            renderBlankCanvas();
        });

        function initializeSignaturePad() {
            const signatureCanvas = document.getElementById('signature-pad');
            signaturePad = new SignaturePad(signatureCanvas, {
                backgroundColor: 'rgba(255, 255, 255, 0)',
                penColor: colorMap[currentSignatureColor], // Use map for initial hex color
            });
            resizeSignatureCanvas(); // Initial resize
        }

        function resizeSignatureCanvas() {
            if (!signaturePad) return;
            const canvasEl = document.getElementById('signature-pad');
            const ratio = Math.max(window.devicePixelRatio || 1, 1);
            canvasEl.width = canvasEl.offsetWidth * ratio;
            canvasEl.height = canvasEl.offsetHeight * ratio;
            canvasEl.getContext('2d').scale(ratio, ratio);
            signaturePad.clear(); // Clear after resize needed
        }

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // Toolbar Buttons
            document.getElementById('upload-btn').addEventListener('click', () => document.getElementById('file-input').click());
            document.getElementById('file-input').addEventListener('change', handleFileSelect);
            document.getElementById('text-tool').addEventListener('click', () => toggleTool('text', 'text-tool-panel'));
            document.getElementById('signature-tool').addEventListener('click', handleSignatureToolClick);
            document.getElementById('image-tool').addEventListener('click', () => toggleTool('image', 'image-tool-panel'));
            document.getElementById('highlight-tool').addEventListener('click', handleHighlightToolClick);
            document.getElementById('save-pdf').addEventListener('click', savePDF);

            // Page Navigation & Zoom
            document.getElementById('page-select').addEventListener('change', handlePageChange);
            document.getElementById('zoom-in').addEventListener('click', () => updateZoom(0.25));
            document.getElementById('zoom-out').addEventListener('click', () => updateZoom(-0.25));

            // PDF Viewer Interaction
            document.getElementById('pdf-viewer').addEventListener('click', handleViewerClick);

            // Text Tool Panel Controls
            setupTextPanelListeners();

            // Signature Tool Panel Controls
            setupSignaturePanelListeners();

            // Image Tool Panel Controls
            setupImagePanelListeners();

            // Highlight Tool Panel Controls
            setupHighlightPanelListeners();
        }

        // --- Event Handler Functions ---
        function toggleTool(toolName, panelId) {
            if (activeTool === toolName) {
                document.getElementById(panelId)?.style.display = 'none';
                setActiveTool(null);
            } else {
                setActiveTool(toolName);
                showToolPanel(panelId);
            }
        }

        function handleSignatureToolClick() {
            toggleTool('signature', 'signature-tool-panel');
            if (activeTool === 'signature') { // Reset signature panel state on activation
                document.getElementById('signature-draw-container').classList.remove('hidden');
                document.getElementById('signature-type-container').classList.add('hidden');
                document.getElementById('initials-text').classList.add('hidden');
                document.getElementById('signature-text').classList.remove('hidden');
                document.getElementById('draw-signature').classList.add('bg-primary', 'text-white');
                document.getElementById('type-signature').classList.remove('bg-primary', 'text-white');
                document.getElementById('initials-btn').classList.remove('bg-primary', 'text-white');
                setSignatureColor(currentSignatureColor);
                signaturePad?.clear();
            }
        }

         function handleHighlightToolClick() {
             toggleTool('highlight', 'highlight-tool-panel');
             if (activeTool === 'highlight') {
                 updateHighlightPanelColors(currentHighlightProperties.opacity);
             }
         }

        function handlePageChange() {
            const selectedPage = parseInt(this.value);
            if (pdfDoc && selectedPage !== pageNum) {
                pageNum = selectedPage;
                queueRenderPage(pageNum);
            }
        }

        function updateZoom(delta) {
            if (!pdfDoc) return;
            const newScale = Math.max(0.25, Math.min(3.0, scale + delta)); // Adjusted min scale
            if (newScale !== scale) {
                scale = newScale;
                queueRenderPage(pageNum);
            }
        }

        function handleViewerClick(e) {
            const clickedAnnotation = e.target.closest('.annotation');
            const clickedCanvasArea = (e.target === canvas || e.target.closest('#pdf-render')) && !clickedAnnotation;

            if (clickedAnnotation) {
                if (selectedAnnotation === clickedAnnotation && e.target.classList.contains('editable-text')) {
                    return; // Allow browser focus on text
                }
                selectAnnotation(clickedAnnotation);
                return; // Prevent triggering other handlers
            }

            if (clickedCanvasArea && activeTool && pdfDoc) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                if (activeTool === 'text' || activeTool === 'highlight') {
                    addAnnotation(x, y);
                }
                // Signature/Image added via panels
            } else if (!clickedAnnotation && !e.target.closest('.tool-panel') && !e.target.closest('.group > button')) {
                // Clicked outside interactive elements -> Deselect
                clearSelection();
            }
        }

        function setupTextPanelListeners() {
             document.querySelectorAll('#text-tool-panel .font-option').forEach(option => {
                 option.addEventListener('click', function() {
                     document.querySelectorAll('#text-tool-panel .font-option').forEach(opt => opt.classList.remove('selected'));
                     this.classList.add('selected');
                     currentTextProperties.fontFamily = this.style.fontFamily;
                     updateSelectedAnnotation();
                 });
             });
             document.getElementById('text-size').addEventListener('input', function() {
                 currentTextProperties.fontSize = parseInt(this.value);
                 updateSelectedAnnotation();
             });
              document.querySelectorAll('#text-tool-panel .color-option').forEach(option => {
                  option.addEventListener('click', function() {
                      document.querySelectorAll('#text-tool-panel .color-option').forEach(opt => opt.classList.remove('selected'));
                      this.classList.add('selected');
                      currentTextProperties.color = this.dataset.color;
                      updateSelectedAnnotation();
                  });
              });
             document.getElementById('bold-text').addEventListener('click', function() {
                 currentTextProperties.bold = !currentTextProperties.bold;
                 this.classList.toggle('bg-gray-200', currentTextProperties.bold);
                 updateSelectedAnnotation();
             });
             document.getElementById('italic-text').addEventListener('click', function() {
                 currentTextProperties.italic = !currentTextProperties.italic;
                 this.classList.toggle('bg-gray-200', currentTextProperties.italic);
                 updateSelectedAnnotation();
             });
             document.getElementById('underline-text').addEventListener('click', function() {
                 currentTextProperties.underline = !currentTextProperties.underline;
                 this.classList.toggle('bg-gray-200', currentTextProperties.underline);
                 updateSelectedAnnotation();
             });
        }

        function setupSignaturePanelListeners() {
             document.getElementById('draw-signature').addEventListener('click', function() {
                 switchSignatureMode(this, 'draw-signature');
                 document.getElementById('signature-draw-container').classList.remove('hidden');
                 document.getElementById('signature-type-container').classList.add('hidden');
                 resizeSignatureCanvas(); // Ensure canvas ready
             });
              document.getElementById('type-signature').addEventListener('click', function() {
                 switchSignatureMode(this, 'type-signature');
                 document.getElementById('signature-draw-container').classList.add('hidden');
                 document.getElementById('signature-type-container').classList.remove('hidden');
                 document.getElementById('signature-text').classList.remove('hidden');
                 document.getElementById('initials-text').classList.add('hidden');
              });
              document.getElementById('initials-btn').addEventListener('click', function() {
                 switchSignatureMode(this, 'initials-btn');
                 document.getElementById('signature-draw-container').classList.add('hidden');
                 document.getElementById('signature-type-container').classList.remove('hidden');
                 document.getElementById('signature-text').classList.add('hidden');
                 document.getElementById('initials-text').classList.remove('hidden');
              });
             document.getElementById('clear-signature').addEventListener('click', function() {
                 signaturePad?.clear();
                 document.getElementById('signature-text').value = '';
                 document.getElementById('initials-text').value = '';
             });
             document.getElementById('save-signature').addEventListener('click', addSignatureFromPanel);
        }

        function switchSignatureMode(buttonElement, activeId) {
             const buttons = [
                 document.getElementById('draw-signature'),
                 document.getElementById('type-signature'),
                 document.getElementById('initials-btn')
             ];
             buttons.forEach(btn => {
                 btn.classList.remove('bg-primary', 'text-white');
                 btn.classList.add('bg-gray-100');
             });
             buttonElement.classList.add('bg-primary', 'text-white');
             buttonElement.classList.remove('bg-gray-100');
         }

        function addSignatureFromPanel() {
            const drawContainerVisible = !document.getElementById('signature-draw-container').classList.contains('hidden');
            const typeContainerVisible = !document.getElementById('signature-type-container').classList.contains('hidden');
            const initialsVisible = typeContainerVisible && !document.getElementById('initials-text').classList.contains('hidden');
            const signatureTextVisible = typeContainerVisible && !document.getElementById('signature-text').classList.contains('hidden');

            let added = false;
            if (drawContainerVisible && signaturePad && !signaturePad.isEmpty()) {
                const signatureData = signaturePad.toDataURL('image/png');
                createSignatureAnnotation(signatureData, 'drawing');
                added = true;
            } else if (initialsVisible && document.getElementById('initials-text').value) {
                createSignatureAnnotation(document.getElementById('initials-text').value, 'initials');
                added = true;
            } else if (signatureTextVisible && document.getElementById('signature-text').value) {
                createSignatureAnnotation(document.getElementById('signature-text').value, 'typed');
                added = true;
            } else {
                // Provide feedback
                if (drawContainerVisible && signaturePad?.isEmpty()) alert('Please draw your signature.');
                else if (initialsVisible && !document.getElementById('initials-text').value) alert('Please type your initials.');
                else if (signatureTextVisible && !document.getElementById('signature-text').value) alert('Please type your signature.');
                else alert('Please create a signature first.');
            }

            if (added) {
                signaturePad?.clear();
                document.getElementById('signature-text').value = '';
                document.getElementById('initials-text').value = '';
                // Optionally close panel: toggleTool('signature', 'signature-tool-panel');
            }
        }

        function setupImagePanelListeners() {
             document.getElementById('browse-images').addEventListener('click', () => document.getElementById('image-input').click());
             document.getElementById('image-input').addEventListener('change', handleImageFileSelect);
             // Drag and Drop
             const dropZone = document.getElementById('image-drop-zone');
             dropZone.addEventListener('dragover', handleDragOver);
             dropZone.addEventListener('dragleave', handleDragLeave);
             dropZone.addEventListener('drop', handleImageDrop);
             // Also allow clicking the drop zone to trigger file input
             dropZone.addEventListener('click', (e) => {
                 if (e.target === dropZone || e.target.tagName === 'I' || e.target.tagName === 'P') {
                      document.getElementById('image-input').click();
                  }
             });
         }

        function handleImageFileSelect(e) {
            const file = e.target.files[0];
            processImageFile(file);
            e.target.value = null; // Reset input
        }

        function handleDragOver(e) {
            e.preventDefault(); e.stopPropagation();
            e.currentTarget.classList.add('border-primary', 'bg-indigo-50');
        }
        function handleDragLeave(e) {
            e.preventDefault(); e.stopPropagation();
            e.currentTarget.classList.remove('border-primary', 'bg-indigo-50');
        }
        function handleImageDrop(e) {
            e.preventDefault(); e.stopPropagation();
            e.currentTarget.classList.remove('border-primary', 'bg-indigo-50');
            const file = e.dataTransfer.files[0];
            processImageFile(file);
        }

        function processImageFile(file) {
             if (file && file.type.startsWith('image/')) {
                 const reader = new FileReader();
                 reader.onload = (event) => {
                     createImageAnnotation(event.target.result);
                     // Optionally close panel: toggleTool('image', 'image-tool-panel');
                 };
                 reader.readAsDataURL(file);
             } else if (file) {
                 alert("Please select/drop a valid image file (e.g., PNG, JPG, GIF).");
             }
        }


        function setupHighlightPanelListeners() {
             document.querySelectorAll('#highlight-tool-panel .color-option').forEach(option => {
                 option.addEventListener('click', function() {
                     document.querySelectorAll('#highlight-tool-panel .color-option').forEach(opt => opt.classList.remove('selected'));
                     this.classList.add('selected');
                     currentHighlightProperties.color = this.dataset.color;
                     updateSelectedAnnotation();
                 });
             });
             document.getElementById('highlight-opacity').addEventListener('input', function() {
                 currentHighlightProperties.opacity = parseInt(this.value) / 100;
                 updateHighlightPanelColors(currentHighlightProperties.opacity);
                 updateSelectedAnnotation();
             });
        }


        // --- PDF Loading and Rendering ---
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const typedArray = new Uint8Array(e.target.result);
                    resetEditorState(); // Clear everything before loading new PDF
                    loadPDF(typedArray);
                };
                reader.onerror = (e) => { console.error("File reading error:", e); alert('Error reading file.'); };
                reader.readAsArrayBuffer(file);
            } else if (file) {
                alert('Please select a valid PDF file.');
                event.target.value = null;
            }
        }

        function resetEditorState() {
            annotations = [];
            clearSelection();
            setActiveTool(null);
            pageNum = 1;
            scale = 1.0;
            pdfDoc = null;
            document.getElementById('page-select').innerHTML = '<option>N/A</option>';
            // Reset tool properties to default might be needed depending on desired UX
        }


        function loadPDF(data) {
            pdfjsLib.getDocument(data).promise.then(function(pdf) {
                pdfDoc = pdf;
                const pageSelect = document.getElementById('page-select');
                pageSelect.innerHTML = ''; // Clear previous options
                for (let i = 1; i <= pdf.numPages; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = '' + i;
                    pageSelect.appendChild(option);
                }
                pageSelect.value = 1;
                pageNum = 1;
                queueRenderPage(1);
            }).catch(function(error) {
                console.error('Error loading PDF:', error);
                alert('Error loading PDF. The file might be corrupted or invalid.');
                renderBlankCanvas(); // Show blank state on error
            });
        }

        function queueRenderPage(num) {
            if (pageRendering) {
                pageNumPending = num;
            } else {
                renderPage(num);
            }
        }

        function renderPage(num) {
            if (!pdfDoc) return;
            pageRendering = true;
            pageNum = num;
            document.getElementById('page-select').value = num;

            pdfDoc.getPage(num).then(function(page) {
                const viewport = page.getViewport({ scale: scale });
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                const pdfRenderDiv = document.getElementById('pdf-render');
                pdfRenderDiv.style.width = viewport.width + 'px';
                pdfRenderDiv.style.height = viewport.height + 'px';

                const renderContext = { canvasContext: ctx, viewport: viewport };
                const renderTask = page.render(renderContext);

                renderTask.promise.then(() => {
                    pageRendering = false;
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                    redrawAnnotations(); // Redraw after page is done
                }).catch(error => {
                    console.error('Error rendering page:', error);
                    pageRendering = false; // Ensure state is reset on error
                });
            }).catch(error => {
                console.error('Error getting page:', error);
                pageRendering = false;
            });
        }

        function renderBlankCanvas() {
            canvas.width = 800; canvas.height = 1000;
            const pdfRenderDiv = document.getElementById('pdf-render');
            pdfRenderDiv.style.width = canvas.width + 'px';
            pdfRenderDiv.style.height = canvas.height + 'px';
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#555555'; ctx.font = '20px Arial'; ctx.textAlign = 'center';
            ctx.fillText('Upload a PDF to start editing', canvas.width / 2, canvas.height / 2 - 20);
            ctx.font = '14px Arial';
            ctx.fillText('(Use the upload button on the left)', canvas.width / 2, canvas.height / 2 + 10);
            document.getElementById('page-select').innerHTML = '<option>N/A</option>';
            annotations = [];
            redrawAnnotations(); // Clear visuals
        }

        // --- Tool State Management ---
        function setActiveTool(tool) {
             // Deactivate previous button
             if (activeTool && document.getElementById(`${activeTool}-tool`)) {
                 document.getElementById(`${activeTool}-tool`).classList.remove('active-tool');
             }
             // Hide all panels
             document.querySelectorAll('.tool-panel').forEach(panel => panel.style.display = 'none');

             activeTool = tool; // Set the new tool

             // Activate new button
             if (activeTool && document.getElementById(`${activeTool}-tool`)) {
                 document.getElementById(`${activeTool}-tool`).classList.add('active-tool');
             }

             // Update cursor
             canvas.style.cursor = (tool === 'text') ? 'text' :
                                  (tool === 'highlight') ? 'crosshair' :
                                  'default';

            clearSelection(); // Clear annotation selection when tool changes
        }

        function showToolPanel(panelId) {
             // Hide all panels first (safety)
             document.querySelectorAll('.tool-panel').forEach(panel => panel.style.display = 'none');
             if (panelId && activeTool) { // Show only if tool is active
                 const panel = document.getElementById(panelId);
                 if (panel) panel.style.display = 'block';
             }
        }

        // --- Annotation Creation ---
        function addAnnotation(x, y) {
            // Only for TEXT and HIGHLIGHT added by direct click
            if (!activeTool || (activeTool !== 'text' && activeTool !== 'highlight') || !pdfDoc) return;

            const annotationId = 'annotation-' + Date.now();
            const annotationDiv = document.createElement('div');
            annotationDiv.className = 'annotation';
            annotationDiv.id = annotationId;
            annotationDiv.style.left = x + 'px';
            annotationDiv.style.top = y + 'px';

             let annotationData = {
                 id: annotationId, type: activeTool, page: pageNum, x: x, y: y,
                 width: 0, height: 0, properties: null, content: null
             };

            if (activeTool === 'text') {
                 annotationDiv.style.width = '200px';
                 annotationDiv.style.height = '30px'; // Initial size

                 const editableDiv = document.createElement('div');
                 editableDiv.className = 'editable-text';
                 editableDiv.contentEditable = true;
                 editableDiv.textContent = "Type here";
                 // Apply current styles
                 Object.assign(editableDiv.style, {
                     fontFamily: currentTextProperties.fontFamily,
                     fontSize: currentTextProperties.fontSize + 'px',
                     color: colorMap[currentTextProperties.color] || '#000000', // Use hex for display
                     fontWeight: currentTextProperties.bold ? 'bold' : 'normal',
                     fontStyle: currentTextProperties.italic ? 'italic' : 'normal',
                     textDecoration: currentTextProperties.underline ? 'underline' : 'none'
                 });

                 // Focus and place cursor at end
                 setTimeout(() => {
                     editableDiv.focus();
                     const range = document.createRange();
                     const sel = window.getSelection();
                     range.selectNodeContents(editableDiv);
                     range.collapse(false);
                     sel.removeAllRanges();
                     sel.addRange(range);
                 }, 0);

                 // Update data store on input
                 editableDiv.addEventListener('input', function() {
                     const annotation = annotations.find(a => a.id === annotationId);
                     if (annotation) {
                         annotation.content = editableDiv.textContent;
                         // Debounce height/width update if needed:
                         // clearTimeout(annotation.resizeTimeout);
                         // annotation.resizeTimeout = setTimeout(() => {
                         //     annotation.height = annotationDiv.offsetHeight;
                         //     annotation.width = annotationDiv.offsetWidth;
                         // }, 250);
                     }
                 });

                 annotationDiv.appendChild(editableDiv);
                 annotationData.width = parseInt(annotationDiv.style.width);
                 annotationData.height = parseInt(annotationDiv.style.height);
                 annotationData.properties = {...currentTextProperties};
                 annotationData.content = "Type here";

            } else if (activeTool === 'highlight') {
                annotationDiv.style.width = '100px';
                annotationDiv.style.height = '20px';
                const props = {...currentHighlightProperties};
                annotationDiv.style.backgroundColor = highlightColorMap[props.color]?.replace('##OPACITY##', props.opacity) || 'rgba(255, 255, 0, 0.5)';
                annotationDiv.style.zIndex = 4;
                annotationData.width = parseInt(annotationDiv.style.width);
                annotationData.height = parseInt(annotationDiv.style.height);
                annotationData.properties = props;
            }

            // Add delete button
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = 'Ã—';
            deleteBtn.onmousedown = (event) => { event.stopPropagation(); deleteAnnotation(annotationDiv); };
            annotationDiv.appendChild(deleteBtn);

            setupDraggable(annotationDiv); // Setup interaction
            document.getElementById('pdf-container').appendChild(annotationDiv);
            annotations.push(annotationData); // Add to data store
            selectAnnotation(annotationDiv); // Select the new one
        }

        function createSignatureAnnotation(content, type) {
             if (!pdfDoc) return;
             const signatureId = 'signature-' + Date.now();
             const signatureDiv = document.createElement('div');
             signatureDiv.className = 'annotation';
             signatureDiv.id = signatureId;
             signatureDiv.style.overflow = 'visible';

             let sigWidth = 200, sigHeight = (type === 'drawing') ? 80 : 60;
             signatureDiv.style.width = sigWidth + 'px';
             signatureDiv.style.height = sigHeight + 'px';
             signatureDiv.style.cursor = 'move';

             // Calculate initial position (centered in view)
             const { x: initialX, y: initialY } = calculateCenteredPosition(sigWidth, sigHeight);
             signatureDiv.style.left = initialX + 'px';
             signatureDiv.style.top = initialY + 'px';

             let properties = null;
             if (type === 'drawing') {
                 signatureDiv.innerHTML = `<img src="${content}" style="width:100%; height:100%; object-fit: contain; display: block; pointer-events: none;" />`;
             } else { // Typed or Initials
                const font = document.getElementById('signature-font').value;
                const colorName = currentTypedSignatureColor; // Use the specific state var
                properties = { font: font, color: colorName }; // Store color name
                const colorHex = colorMap[colorName] || '#000000';
                signatureDiv.innerHTML = `<div style="font-family:${font}; color:${colorHex}; font-size:${type === 'initials' ? '32px' : '24px'}; width:100%; height:100%; display:flex; align-items:center; justify-content:center; white-space: nowrap; box-sizing: border-box; overflow: hidden; pointer-events: none;">${content}</div>`;
             }

             const deleteBtn = createDeleteButton(signatureDiv);
             signatureDiv.appendChild(deleteBtn);
             setupDraggable(signatureDiv);
             document.getElementById('pdf-container').appendChild(signatureDiv);

             const annotation = {
                 id: signatureId, type: 'signature', signatureType: type, page: pageNum,
                 x: initialX, y: initialY, width: sigWidth, height: sigHeight,
                 content: content, properties: properties
             };
             annotations.push(annotation);
             selectAnnotation(signatureDiv);
        }

        function createImageAnnotation(imageData) {
            if (!pdfDoc) return;
            const imageId = 'image-' + Date.now();
            const imageDiv = document.createElement('div');
            imageDiv.className = 'annotation';
            imageDiv.id = imageId;
            imageDiv.style.overflow = 'hidden'; // Images should clip

            let initialWidth = 200;
            imageDiv.style.width = initialWidth + 'px';
            imageDiv.style.height = 'auto'; // Resolve after load

            // Calculate initial position
            const { x: initialX, y: initialY } = calculateCenteredPosition(initialWidth, 150); // Guess height for positioning
            imageDiv.style.left = initialX + 'px';
            imageDiv.style.top = initialY + 'px';

            const img = document.createElement('img');
            img.style.cssText = "width:100%; height:100%; object-fit:contain; display:block; pointer-events:none;";
            imageDiv.appendChild(img);

            const deleteBtn = createDeleteButton(imageDiv);
            imageDiv.appendChild(deleteBtn);

            // Add annotation data structure *before* load, update height later
            const annotation = {
                 id: imageId, type: 'image', page: pageNum,
                 x: initialX, y: initialY, width: initialWidth, height: 'auto',
                 content: imageData, properties: null
            };
             annotations.push(annotation); // Add data immediately

             img.onload = () => {
                 const aspectRatio = img.naturalWidth / img.naturalHeight;
                 let loadedHeight = 150; // Fallback
                 if (aspectRatio && isFinite(aspectRatio)) {
                     loadedHeight = initialWidth / aspectRatio;
                 }
                 imageDiv.style.height = loadedHeight + 'px';
                 annotation.height = loadedHeight; // Update stored height
                 // Re-clamp Y position based on actual height
                 annotation.y = Math.max(0, Math.min(annotation.y, canvas.height - loadedHeight));
                 imageDiv.style.top = annotation.y + 'px';

                 document.getElementById('pdf-container').appendChild(imageDiv); // Add to DOM only after load success
                 setupDraggable(imageDiv);
                 selectAnnotation(imageDiv);
             };
             img.onerror = () => {
                 console.error("Failed to load image:", imageData.substring(0, 50) + "...");
                 alert("Error loading image.");
                 // Remove the annotation data if load fails
                 annotations = annotations.filter(a => a.id !== imageId);
             };
             img.src = imageData; // Start loading
        }

        // --- Annotation Manipulation & Interaction ---

        function createDeleteButton(parentAnnotationDiv) {
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = 'Ã—';
            deleteBtn.onmousedown = (event) => { // Use mousedown to prevent interference
                event.stopPropagation();
                deleteAnnotation(parentAnnotationDiv);
            };
            return deleteBtn;
        }

        function calculateCenteredPosition(elementWidth, elementHeight) {
             const container = document.getElementById('pdf-container');
             const viewer = document.getElementById('pdf-viewer');
             const canvasRect = canvas.getBoundingClientRect(); // Position relative to viewport
             const viewerRect = viewer.getBoundingClientRect();

             // Center based on viewer's visible area + scroll
             const viewCenterX = viewer.scrollLeft + viewerRect.width / 2;
             const viewCenterY = viewer.scrollTop + viewerRect.height / 2;

             // Convert view center to coordinates relative to the PDF canvas
             let x = viewCenterX - canvasRect.left - (elementWidth / 2);
             let y = viewCenterY - canvasRect.top - (elementHeight / 2);

             // Clamp position to be within canvas boundaries
             x = Math.max(0, Math.min(x, canvas.width - elementWidth));
             y = Math.max(0, Math.min(y, canvas.height - elementHeight));

             return { x, y };
        }


        function setupDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false, isResizing = false;
            const pdfContainer = document.getElementById('pdf-container');

            element.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                 if (e.target.classList.contains('delete-btn')) return; // Handled by button's listener

                 const rect = element.getBoundingClientRect();
                 const resizeHandleSize = 16;
                 const onResizeHandle = e.clientX >= rect.right - resizeHandleSize && e.clientX <= rect.right + 2 &&
                                      e.clientY >= rect.bottom - resizeHandleSize && e.clientY <= rect.bottom + 2;

                 if (onResizeHandle && getComputedStyle(element).resize !== 'none') {
                     isResizing = true; isDragging = false;
                     pos3 = e.clientX; pos4 = e.clientY;
                     document.body.style.cursor = 'nwse-resize';
                 } else if (!e.target.isContentEditable) { // Start drag only if not clicking editable content
                     isResizing = false; isDragging = true;
                     pos3 = e.clientX; pos4 = e.clientY;
                     element.style.cursor = 'move';
                 } else {
                     return; // Allow text selection/editing
                 }

                e.preventDefault(); e.stopPropagation();
                document.addEventListener('mousemove', elementDrag);
                document.addEventListener('mouseup', closeDragElement);
            }

            function elementDrag(e) {
                 e.preventDefault(); e.stopPropagation(); // Prevent text selection during drag/resize

                 if (isResizing) {
                     const dx = e.clientX - pos3; const dy = e.clientY - pos4;
                     let newWidth = element.offsetWidth + dx; let newHeight = element.offsetHeight + dy;
                     const minWidth = 30, minHeight = 20;
                     newWidth = Math.max(minWidth, newWidth); newHeight = Math.max(minHeight, newHeight);

                     // Boundary checks
                     newWidth = Math.min(newWidth, pdfContainer.offsetWidth - element.offsetLeft);
                     newHeight = Math.min(newHeight, pdfContainer.offsetHeight - element.offsetTop);

                     element.style.width = newWidth + 'px';

                     // Image aspect ratio
                     const img = element.querySelector('img');
                     const annotation = annotations.find(a => a.id === element.id);
                     if (annotation?.type === 'image' && img?.naturalWidth > 0) {
                         const aspectRatio = img.naturalWidth / img.naturalHeight;
                         if (aspectRatio && isFinite(aspectRatio)) {
                              newHeight = newWidth / aspectRatio;
                              element.style.height = Math.max(minHeight, newHeight) + 'px';
                          } else { element.style.height = newHeight + 'px'; }
                     } else { element.style.height = newHeight + 'px'; }

                     pos3 = e.clientX; pos4 = e.clientY; // Update ref point

                 } else if (isDragging) {
                     pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY;
                     pos3 = e.clientX; pos4 = e.clientY;
                     let newTop = element.offsetTop - pos2; let newLeft = element.offsetLeft - pos1;

                     // Boundary checks
                     newLeft = Math.max(0, Math.min(newLeft, pdfContainer.offsetWidth - element.offsetWidth));
                     newTop = Math.max(0, Math.min(newTop, pdfContainer.offsetHeight - element.offsetHeight));

                     element.style.top = newTop + "px"; element.style.left = newLeft + "px";
                 }
                 updateAnnotationData(element); // Update stored data
            }

            function closeDragElement(e) {
                 e.stopPropagation();
                 document.removeEventListener('mousemove', elementDrag);
                 document.removeEventListener('mouseup', closeDragElement);
                 element.style.cursor = 'move'; // Reset cursor
                 document.body.style.cursor = 'default';

                 if (isDragging || isResizing) { updateAnnotationData(element); } // Final update
                 isDragging = false; isResizing = false;
            }

            function updateAnnotationData(el) {
                 const annotation = annotations.find(a => a.id === el.id);
                 if (annotation) {
                     annotation.x = el.offsetLeft; annotation.y = el.offsetTop;
                     annotation.width = el.offsetWidth; annotation.height = el.offsetHeight;
                     if (annotation.type === 'text') {
                         const editableDiv = el.querySelector('.editable-text');
                         if (editableDiv) annotation.content = editableDiv.textContent; // Sync content
                     }
                 }
            }
        }

        function selectAnnotation(annotationElement) {
            if (!annotationElement || selectedAnnotation === annotationElement) {
                 // If clicking the same one, only proceed if it's not the editable text itself
                 if (event?.target?.classList.contains('editable-text')) return;
                 // If same element but not editable text click, maybe deselect? Or just do nothing.
                 // Let's do nothing for now if re-clicking the same non-text area.
                 if (selectedAnnotation === annotationElement) return;
             }

            clearSelection(); // Clear previous
            annotationElement.classList.add('selected');
            selectedAnnotation = annotationElement; // Store DOM element reference

            const annotation = annotations.find(a => a.id === annotationElement.id);
            if (!annotation) return;

             let panelToShow = null;
             switch (annotation.type) {
                 case 'text':
                     panelToShow = 'text-tool-panel';
                     updateTextPanelControls(annotation.properties);
                     currentTextProperties = {...annotation.properties};
                     setActiveToolButtonOnly('text'); // Highlight tool button
                     break;
                 case 'highlight':
                     panelToShow = 'highlight-tool-panel';
                     updateHighlightPanelControls(annotation.properties);
                     currentHighlightProperties = {...annotation.properties};
                     setActiveToolButtonOnly('highlight');
                     break;
                 case 'signature':
                 case 'image':
                     setActiveToolButtonOnly(null); // No panel, remove tool highlight
                     break;
                 default:
                     setActiveToolButtonOnly(null);
                     break;
             }
             showToolPanel(panelToShow); // Show relevant panel or hide all
        }

        function setActiveToolButtonOnly(toolName) {
             document.querySelectorAll('.group > button[id$="-tool"]').forEach(btn => {
                 btn.classList.remove('active-tool');
             });
             if (toolName && document.getElementById(`${toolName}-tool`)) {
                 document.getElementById(`${toolName}-tool`).classList.add('active-tool');
             }
         }

        function clearSelection() {
            if (selectedAnnotation) {
                selectedAnnotation.classList.remove('selected');
                selectedAnnotation = null;
            }
            // Don't hide panels or change active tool on simple deselect
        }

        function updateSelectedAnnotation() {
            if (!selectedAnnotation) return;
            const annotation = annotations.find(a => a.id === selectedAnnotation.id);
            if (!annotation) return;

            if (annotation.type === 'text') {
                annotation.properties = {...currentTextProperties}; // Update data store
                // Update visual appearance
                const editableDiv = selectedAnnotation.querySelector('.editable-text');
                if (editableDiv) {
                     Object.assign(editableDiv.style, {
                         fontFamily: currentTextProperties.fontFamily,
                         fontSize: currentTextProperties.fontSize + 'px',
                         color: colorMap[currentTextProperties.color] || '#000000', // Use hex for display
                         fontWeight: currentTextProperties.bold ? 'bold' : 'normal',
                         fontStyle: currentTextProperties.italic ? 'italic' : 'normal',
                         textDecoration: currentTextProperties.underline ? 'underline' : 'none'
                     });
                 }
            } else if (annotation.type === 'highlight') {
                annotation.properties = {...currentHighlightProperties}; // Update data store
                const props = annotation.properties;
                selectedAnnotation.style.backgroundColor = highlightColorMap[props.color]?.replace('##OPACITY##', props.opacity) || 'rgba(255, 255, 0, 0.5)';
            }
        }

        function deleteAnnotation(element) {
            if (!element || !element.id) return;
            const annotationId = element.id;
            element.remove(); // Remove from DOM
            annotations = annotations.filter(a => a.id !== annotationId); // Remove from data
            if (selectedAnnotation && selectedAnnotation.id === annotationId) {
                 clearSelection(); // Clear selection state if deleted element was selected
            }
        }

        // --- Panel UI Update Helpers ---
        function updateTextPanelControls(properties) {
              const props = properties || currentTextProperties; // Use defaults if none provided
              // Font Family
              let familyFound = false;
              document.querySelectorAll('#text-tool-panel .font-option').forEach(opt => {
                  const targetFont = (props.fontFamily || 'Arial').replace(/['"]/g, '').toLowerCase();
                  const optionFont = opt.style.fontFamily.replace(/['"]/g, '').toLowerCase();
                  const isSelected = optionFont.includes(targetFont) || targetFont.includes(optionFont);
                  opt.classList.toggle('selected', isSelected);
                  if (isSelected) familyFound = true;
              });
              if (!familyFound) document.querySelector('#text-tool-panel .font-option[style*="Arial"]')?.classList.add('selected');
              // Font Size
              document.getElementById('text-size').value = props.fontSize || 14;
              // Color
               const targetColor = props.color || 'black';
               let colorFound = false;
               document.querySelectorAll('#text-tool-panel .color-option').forEach(opt => {
                    const isSelected = opt.dataset.color === targetColor;
                    opt.classList.toggle('selected', isSelected);
                    if (isSelected) colorFound = true;
                });
                if (!colorFound) document.querySelector('#text-tool-panel .color-option[data-color="black"]')?.classList.add('selected');
              // Styles
              document.getElementById('bold-text').classList.toggle('bg-gray-200', props.bold || false);
              document.getElementById('italic-text').classList.toggle('bg-gray-200', props.italic || false);
              document.getElementById('underline-text').classList.toggle('bg-gray-200', props.underline || false);
         }

         function updateHighlightPanelControls(properties) {
             const props = properties || currentHighlightProperties;
             const targetColor = props.color || 'yellow';
             document.querySelectorAll('#highlight-tool-panel .color-option').forEach(opt => {
                 opt.classList.toggle('selected', opt.dataset.color === targetColor);
             });
             document.getElementById('highlight-opacity').value = (props.opacity || 0.5) * 100;
             updateHighlightPanelColors(props.opacity || 0.5);
         }

         function updateHighlightPanelColors(opacity) {
            document.querySelectorAll('#highlight-tool-panel .color-option').forEach(opt => {
                 const colorBase = highlightColorMap[opt.dataset.color] || highlightColorMap['yellow'];
                 opt.style.backgroundColor = colorBase.replace('##OPACITY##', opacity);
             });
         }

        // --- Redrawing Annotations on Page Change/Zoom ---
        function redrawAnnotations() {
             const container = document.getElementById('pdf-container');
             container.querySelectorAll('.annotation').forEach(el => el.remove()); // Clear existing DOM elements

             annotations.filter(a => a.page === pageNum).forEach(annotation => {
                 const annotationDiv = document.createElement('div');
                 annotationDiv.className = 'annotation';
                 annotationDiv.id = annotation.id;
                 annotationDiv.style.left = annotation.x + 'px';
                 annotationDiv.style.top = annotation.y + 'px';
                 annotationDiv.style.width = annotation.width + 'px';
                 annotationDiv.style.height = (typeof annotation.height === 'number' && annotation.height > 0) ? annotation.height + 'px' : '30px';
                 annotationDiv.style.overflow = 'visible';

                 const deleteBtn = createDeleteButton(annotationDiv);

                 if (annotation.type === 'text') {
                     const props = annotation.properties || {};
                     const editableDiv = document.createElement('div');
                     editableDiv.className = 'editable-text';
                     editableDiv.contentEditable = true;
                     editableDiv.textContent = annotation.content || '';
                     Object.assign(editableDiv.style, {
                         fontFamily: props.fontFamily || 'Arial',
                         fontSize: (props.fontSize || 14) + 'px',
                         color: colorMap[props.color || 'black'] || '#000000',
                         fontWeight: props.bold ? 'bold' : 'normal',
                         fontStyle: props.italic ? 'italic' : 'normal',
                         textDecoration: props.underline ? 'underline' : 'none'
                     });
                      // Listener to update data store when text is edited
                     editableDiv.addEventListener('input', function() {
                          annotation.content = editableDiv.textContent;
                          // Consider debounced height/width update here too if needed
                      });
                     annotationDiv.appendChild(editableDiv);

                 } else if (annotation.type === 'highlight') {
                    const props = annotation.properties || {};
                    annotationDiv.style.backgroundColor = highlightColorMap[props.color || 'yellow']?.replace('##OPACITY##', props.opacity || 0.5);
                    annotationDiv.style.zIndex = 4;

                 } else if (annotation.type === 'signature') {
                     annotationDiv.style.overflow = 'visible';
                     if (annotation.signatureType === 'drawing') {
                         annotationDiv.innerHTML = `<img src="${annotation.content}" style="width:100%; height:100%; object-fit: contain; display: block; pointer-events: none;" />`;
                     } else {
                         const props = annotation.properties || {};
                         const colorHex = colorMap[props.color || 'black'] || '#000000';
                         annotationDiv.innerHTML = `<div style="font-family:${props.font || 'Arial'}; color:${colorHex}; font-size:${annotation.signatureType === 'initials' ? '32px' : '24px'}; width:100%; height:100%; display:flex; align-items:center; justify-content:center; white-space: nowrap; overflow: hidden; box-sizing: border-box; pointer-events: none;">${annotation.content}</div>`;
                     }

                 } else if (annotation.type === 'image') {
                     annotationDiv.style.overflow = 'hidden';
                     const img = document.createElement('img');
                     img.src = annotation.content;
                     img.style.cssText = "width:100%; height:100%; object-fit:contain; display:block; pointer-events:none;";
                     annotationDiv.appendChild(img);
                     // Ensure height is correctly applied if it was resolved from 'auto'
                     if (typeof annotation.height === 'number') {
                         annotationDiv.style.height = annotation.height + 'px';
                     }
                 }

                 annotationDiv.appendChild(deleteBtn); // Add delete last
                 setupDraggable(annotationDiv);
                 container.appendChild(annotationDiv);

                 // Reselect if necessary
                 if (selectedAnnotation && selectedAnnotation.id === annotation.id) {
                     annotationDiv.classList.add('selected');
                     selectedAnnotation = annotationDiv; // Update reference
                 }
             });
        }

        // --- PDF Saving ---
        async function savePDF() {
            if (!pdfDoc) { alert('No PDF loaded to save.'); return; }

            const saveBtn = document.getElementById('save-pdf');
            const originalIcon = saveBtn.innerHTML;
            saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            saveBtn.disabled = true;
            console.log('Starting PDF save...');

            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ unit: 'pt', compress: true }); // Use points (native PDF unit)

                const originalFilename = document.getElementById('file-input').files[0]?.name || 'edited-document.pdf';
                const newFilename = originalFilename.replace(/\.pdf$/i, '-edited.pdf');

                const loadImage = (src) => new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = (err) => { console.error("Image load error:", src.substring(0,50)+"...", err); reject(new Error('Failed to load image')); };
                    img.src = src;
                });

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');

                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    console.log(`Processing page ${i} / ${pdfDoc.numPages}`);
                    const page = await pdfDoc.getPage(i);
                    const viewport = page.getViewport({ scale: 1.0 }); // Use scale 1.0 for saving

                    tempCanvas.width = viewport.width;
                    tempCanvas.height = viewport.height;

                    // 1. Render original PDF page
                    const renderContext = { canvasContext: tempCtx, viewport: viewport };
                    await page.render(renderContext).promise;
                    console.log(` Page ${i}: PDF rendered.`);

                    // 2. Draw annotations for this page
                    const pageAnnotations = annotations.filter(a => a.page === i);
                    console.log(` Page ${i}: Found ${pageAnnotations.length} annotations.`);

                    for (const annotation of pageAnnotations) {
                         // Convert annotation coords/size from display scale to save scale (1.0)
                         const scaledX = annotation.x / scale;
                         const scaledY = annotation.y / scale;
                         const scaledWidth = annotation.width / scale;
                         let scaledHeight = (typeof annotation.height === 'number') ? annotation.height / scale : (30 / scale); // Default fallback
                         const props = annotation.properties || {};

                         tempCtx.save(); // Isolate drawing state
                         console.log(`  Drawing ${annotation.type} annotation ${annotation.id}`);

                         try {
                             if (annotation.type === 'text') {
                                const fontSize = (props.fontSize || 14) / scale; // Scale font size
                                const fontFamily = props.fontFamily || 'Arial';
                                const fontWeight = props.bold ? 'bold ' : '';
                                const fontStyle = props.italic ? 'italic ' : '';
                                const colorName = props.color || 'black';
                                const colorHex = colorMap[colorName] || '#000000'; // Use Hex color

                                tempCtx.font = `${fontWeight}${fontStyle}${fontSize}px ${fontFamily}`;
                                tempCtx.fillStyle = colorHex;
                                tempCtx.textBaseline = 'top'; // Align text from top-left

                                const lines = (annotation.content || '').split('\n');
                                const lineHeight = fontSize * 1.2; // Estimate line height

                                for(let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                                    const currentLine = lines[lineIndex];
                                    const lineY = scaledY + (lineIndex * lineHeight);
                                    tempCtx.fillText(currentLine, scaledX, lineY); // Draw text line

                                    // Draw underline if needed
                                    if (props.underline) {
                                        const textMetrics = tempCtx.measureText(currentLine);
                                        const underlineOffset = Math.max(0.5, fontSize * 0.08); // Relative offset
                                        const underlineY = lineY + fontSize + underlineOffset;
                                        const underlineWidth = textMetrics.width;
                                        const underlineThickness = Math.max(0.5, fontSize * 0.05); // Relative thickness

                                        tempCtx.beginPath();
                                        tempCtx.strokeStyle = colorHex; // Match text color
                                        tempCtx.lineWidth = underlineThickness;
                                        tempCtx.moveTo(scaledX, underlineY);
                                        tempCtx.lineTo(scaledX + underlineWidth, underlineY);
                                        tempCtx.stroke();
                                    }
                                }
                                console.log(`    Text drawn: "${annotation.content.substring(0, 20)}..."`);

                             } else if (annotation.type === 'highlight') {
                                const colorKey = props.color || 'yellow';
                                const opacity = props.opacity || 0.5;
                                const colorRgba = highlightColorMap[colorKey]?.replace('##OPACITY##', opacity) || `rgba(255, 255, 0, ${opacity})`;
                                tempCtx.fillStyle = colorRgba;
                                tempCtx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                                console.log(`    Highlight drawn: Color=${colorKey}, Opacity=${opacity}`);

                             } else if (annotation.type === 'signature') {
                                 if (annotation.signatureType === 'drawing') {
                                     const img = await loadImage(annotation.content);
                                     tempCtx.drawImage(img, scaledX, scaledY, scaledWidth, scaledHeight);
                                     console.log(`    Drawn Signature drawn.`);
                                 } else { // Typed or Initials
                                     const fontSize = ((annotation.signatureType === 'initials' ? 32 : 24) / scale);
                                     const fontFamily = props.font || 'Arial';
                                     const colorName = props.color || 'black';
                                     const colorHex = colorMap[colorName] || '#000000'; // Use Hex color
                                     tempCtx.font = `${fontSize}px ${fontFamily}`;
                                     tempCtx.fillStyle = colorHex;
                                     tempCtx.textAlign = 'center';
                                     tempCtx.textBaseline = 'middle';
                                     tempCtx.fillText(annotation.content, scaledX + scaledWidth / 2, scaledY + scaledHeight / 2);
                                     console.log(`    ${annotation.signatureType} Signature drawn: "${annotation.content}"`);
                                 }

                             } else if (annotation.type === 'image') {
                                 const img = await loadImage(annotation.content);
                                 tempCtx.drawImage(img, scaledX, scaledY, scaledWidth, scaledHeight);
                                 console.log(`    Image drawn.`);
                             }

                         } catch (drawError) {
                             console.error(`Error drawing annotation ${annotation.id} on page ${i}:`, drawError);
                         } finally {
                             tempCtx.restore(); // Restore context state
                         }
                     } // End annotation loop

                    // 3. Add composed page to PDF
                    const imgData = tempCanvas.toDataURL('image/png'); // PNG preserves text/lines better
                    if (i > 1) {
                        doc.addPage([viewport.width, viewport.height], 'portrait');
                    }
                    doc.addImage(imgData, 'PNG', 0, 0, viewport.width, viewport.height, undefined, 'FAST');
                    console.log(` Page ${i} added to jsPDF doc.`);

                } // End page loop

                console.log('Saving PDF file:', newFilename);
                doc.save(newFilename); // Trigger download
                console.log('PDF save initiated.');

            } catch (error) {
                console.error('Fatal error during PDF saving:', error);
                alert('An error occurred while saving the PDF. Check console for details.');
            } finally {
                saveBtn.innerHTML = originalIcon;
                saveBtn.disabled = false;
                console.log('Save process finished.');
            }
        }

        // --- Global Helper Functions ---
        // Make functions globally accessible for inline HTML event handlers
        window.setSignatureColor = function(colorName) {
             currentSignatureColor = colorName;
             if (signaturePad) {
                 signaturePad.penColor = colorMap[colorName] || '#000000';
             }
             document.querySelectorAll('#signature-draw-container .color-option').forEach(opt => {
                 opt.classList.toggle('selected', opt.dataset.color === colorName);
             });
         };
        window.setTypedSignatureColor = function(colorName) {
             currentTypedSignatureColor = colorName;
             document.querySelectorAll('#signature-type-container .color-option').forEach(opt => {
                 opt.classList.toggle('selected', opt.dataset.color === colorName);
             });
         };

    </script>
</body>
</html>
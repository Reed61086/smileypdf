<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PDF Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/signature_pad/1.5.3/signature_pad.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5',
                        secondary: '#6B7280',
                        accent: '#10B981',
                        danger: '#EF4444',
                    }
                }
            }
        }
    </script>
    <style>
        #pdf-render {
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin: 0 auto;
            position: relative;
            overflow: hidden;
        }
        .canvas-container {
            position: relative;
            margin: 0 auto;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .annotation {
            position: absolute;
            cursor: move;
            resize: both;
            /* overflow: hidden; */ /* Removed to prevent clipping content like text */
            min-width: 50px;
            min-height: 20px;
            border: 1px dashed transparent;
            z-index: 5; /* Ensure annotations are above the canvas */
        }
        .annotation:hover {
            border-color: #4F46E5;
        }
        .annotation.selected {
            border: 1px dashed #4F46E5;
            background-color: rgba(79, 70, 229, 0.1);
        }
        .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background-color: #EF4444;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .annotation:hover .delete-btn {
            opacity: 1;
        }
        #signature-pad {
            border: 1px solid #e5e7eb;
            background-color: white;
            touch-action: none;
            width: 100%;
        }
        .tool-panel {
            position: absolute;
            left: 70px;
            top: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 10px;
            z-index: 100;
            width: 250px;
            display: none;
        }
        .color-option {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            margin: 3px;
            border: 2px solid white;
        }
        .color-option.selected {
            border-color: #4F46E5;
            transform: scale(1.1);
        }
        .font-option {
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        .font-option.selected {
            background-color: #E5E7EB;
            font-weight: bold;
        }
        .tooltip-text {
            position: absolute;
            left: 60px;
            background-color: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            white-space: nowrap;
            z-index: 1000;
        }
        .group:hover .tooltip-text {
            opacity: 1;
        }
        #signature-type-container {
            margin-top: 10px;
        }
        #file-input {
            display: none;
        }
        #initials-text {
            display: none;
        }
        .active-tool {
            background-color: #4F46E5 !important;
            color: white !important;
        }
        /* Resize handle styling */
        .annotation::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: #4F46E5;
            border-radius: 2px;
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .annotation:hover::after {
            opacity: 1;
        }
        /* Editable text area - Reverted */
        .editable-text {
            min-height: 20px;
            width: 100%;
            outline: none;
            padding: 2px;
            cursor: text;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="flex h-screen overflow-hidden">
        <!-- Left Toolbar -->
        <div class="w-16 bg-white shadow-md flex flex-col items-center py-4 space-y-6">
            <!-- Upload PDF Button -->
            <div class="group relative">
                <button id="upload-btn" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-file-upload text-gray-700"></i>
                </button>
                <input type="file" id="file-input" accept=".pdf">
                <span class="tooltip-text">Upload PDF</span>
            </div>
            
            <!-- Text Tool -->
            <div class="group relative">
                <button id="text-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-font text-gray-700"></i>
                </button>
                <span class="tooltip-text">Text Tool</span>
            </div>
            
            <!-- Signature Tool -->
            <div class="group relative">
                <button id="signature-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-signature text-gray-700"></i>
                </button>
                <span class="tooltip-text">Signature/Initials</span>
            </div>
            
            <!-- Image Tool -->
            <div class="group relative">
                <button id="image-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-image text-gray-700"></i>
                </button>
                <span class="tooltip-text">Image Tool</span>
            </div>
            
            <!-- Highlight Tool -->
            <div class="group relative">
                <button id="highlight-tool" class="w-12 h-12 rounded-lg flex items-center justify-center bg-gray-100 hover:bg-gray-200 transition">
                    <i class="fas fa-highlighter text-gray-700"></i>
                </button>
                <span class="tooltip-text">Highlight Tool</span>
            </div>
            
            <!-- Save Button -->
            <div class="group relative mt-auto">
                <button id="save-pdf" class="w-12 h-12 rounded-lg flex items-center justify-center bg-primary hover:bg-purple-700 transition text-white">
                    <i class="fas fa-save"></i>
                </button>
                <span class="tooltip-text">Save PDF</span>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Top Bar -->
            <div class="bg-white shadow-sm py-3 px-4 flex items-center justify-between">
                <h1 class="text-xl font-semibold text-gray-800">PDF Editor</h1>
                <div class="flex items-center space-x-4">
                    <div>
                        <span class="text-gray-600 mr-2">Page:</span>
                        <select id="page-select" class="border rounded px-2 py-1">
                            <!-- Pages will be added dynamically -->
                        </select>
                    </div>
                    <button id="zoom-in" class="w-8 h-8 rounded flex items-center justify-center hover:bg-gray-100">
                        <i class="fas fa-search-plus text-gray-600"></i>
                    </button>
                    <button id="zoom-out" class="w-8 h-8 rounded flex items-center justify-center hover:bg-gray-100">
                        <i class="fas fa-search-minus text-gray-600"></i>
                    </button>
                </div>
            </div>

            <!-- PDF Viewer -->
            <div class="flex-1 overflow-auto p-6 bg-gray-50" id="pdf-viewer">
                <div id="pdf-container" class="relative mx-auto">
                    <div id="pdf-render" class="canvas-container">
                        <canvas id="pdf-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Text Tool Panel -->
        <div id="text-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Text Properties</h3>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Font Family</label>
                <div class="flex flex-wrap">
                    <div class="font-option selected" style="font-family: 'Arial'">Arial</div>
                    <div class="font-option" style="font-family: 'Times New Roman'">Times</div>
                    <div class="font-option" style="font-family: 'Courier New'">Courier</div>
                    <div class="font-option" style="font-family: 'Georgia'">Georgia</div>
                    <div class="font-option" style="font-family: 'Verdana'">Verdana</div>
                    <div class="font-option" style="font-family: 'Comic Sans MS'">Comic</div>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Font Size</label>
                <input type="range" id="text-size" min="8" max="72" value="14" class="w-full">
                <div class="flex justify-between text-xs text-gray-600">
                    <span>8</span>
                    <span>20</span>
                    <span>32</span>
                    <span>44</span>
                    <span>56</span>
                    <span>72</span>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Text Color</label>
                <div class="flex flex-wrap">
                    <div class="color-option bg-black selected" data-color="black"></div>
                    <div class="color-option bg-red-500" data-color="red"></div>
                    <div class="color-option bg-blue-500" data-color="blue"></div>
                    <div class="color-option bg-green-500" data-color="green"></div>
                    <div class="color-option bg-yellow-500" data-color="yellow"></div>
                    <div class="color-option bg-purple-500" data-color="purple"></div>
                    <div class="color-option bg-pink-500" data-color="pink"></div>
                    <div class="color-option bg-gray-500" data-color="gray"></div>
                </div>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Bold/Italic</label>
                <div class="flex">
                    <button id="bold-text" class="px-3 py-1 border rounded-l hover:bg-gray-100">
                        <i class="fas fa-bold"></i>
                    </button>
                    <button id="italic-text" class="px-3 py-1 border-t border-b hover:bg-gray-100">
                        <i class="fas fa-italic"></i>
                    </button>
                    <button id="underline-text" class="px-3 py-1 border rounded-r hover:bg-gray-100">
                        <i class="fas fa-underline"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Signature Tool Panel -->
        <div id="signature-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Add Signature/Initials</h3>
            <div class="mb-4">
                <div class="flex space-x-3 mb-3">
                    <button id="draw-signature" class="flex-1 py-2 bg-primary text-white rounded hover:bg-purple-700">Draw</button>
                    <button id="type-signature" class="flex-1 py-2 bg-gray-100 rounded hover:bg-gray-200">Type</button>
                    <button id="initials-btn" class="flex-1 py-2 bg-gray-100 rounded hover:bg-gray-200">Initials</button>
                </div>
                <div id="signature-draw-container" class="border rounded mb-3">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-sm font-medium text-gray-700">Pen Color:</label>
                        <div class="flex">
                            <div class="color-option bg-black selected" data-color="black" onclick="setSignatureColor('black')"></div>
                            <div class="color-option bg-red-500" data-color="red" onclick="setSignatureColor('red')"></div>
                            <div class="color-option bg-blue-500" data-color="blue" onclick="setSignatureColor('blue')"></div>
                            <div class="color-option bg-green-500" data-color="green" onclick="setSignatureColor('green')"></div>
                        </div>
                    </div>
                    <canvas id="signature-pad" height="150"></canvas>
                </div>
                <div id="signature-type-container" class="mb-3 hidden">
                    <input type="text" id="signature-text" placeholder="Type your name" class="w-full border rounded px-3 py-2">
                    <input type="text" id="initials-text" placeholder="Type your initials" class="w-full border rounded px-3 py-2 mt-2 hidden">
                    <div class="flex mt-2">
                        <select id="signature-font" class="border rounded px-2 py-1 flex-1 mr-2">
                            <option value="'Brush Script MT', cursive">Brush Script</option>
                            <option value="'Dancing Script', cursive">Dancing Script</option>
                            <option value="'Parisienne', cursive">Parisienne</option>
                            <option value="'Great Vibes', cursive">Great Vibes</option>
                        </select>
                        <div class="flex">
                            <div class="color-option bg-black selected" data-color="black" onclick="setTypedSignatureColor('black')"></div>
                            <div class="color-option bg-red-500" data-color="red" onclick="setTypedSignatureColor('red')"></div>
                            <div class="color-option bg-blue-500" data-color="blue" onclick="setTypedSignatureColor('blue')"></div>
                            <div class="color-option bg-green-500" data-color="green" onclick="setTypedSignatureColor('green')"></div>
                            <div class="color-option bg-purple-500" data-color="purple" onclick="setTypedSignatureColor('purple')"></div>
                        </div>
                    </div>
                </div>
                <div class="flex justify-between">
                    <button id="clear-signature" class="px-3 py-2 bg-gray-200 rounded hover:bg-gray-300">
                        Clear
                    </button>
                    <button id="save-signature" class="px-3 py-2 bg-primary text-white rounded hover:bg-purple-700">
                        Save
                    </button>
                </div>
            </div>
        </div>

        <!-- Image Tool Panel -->
        <div id="image-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Add Image</h3>
            <div class="mb-4">
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center">
                    <i class="fas fa-image text-4xl text-gray-400 mb-2"></i>
                    <p class="text-sm text-gray-500">Drag & drop image here or</p>
                    <button id="browse-images" class="mt-2 px-4 py-2 bg-primary text-white rounded hover:bg-purple-700">
                        Browse Files
                    </button>
                    <input type="file" id="image-input" accept="image/*" class="hidden">
                </div>
            </div>
        </div>

        <!-- Highlight Tool Panel -->
        <div id="highlight-tool-panel" class="tool-panel">
            <h3 class="font-medium mb-2">Highlight Properties</h3>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Highlight Color</label>
                <div class="flex flex-wrap">
                    <div class="color-option bg-yellow-200 selected" data-color="yellow"></div>
                    <div class="color-option bg-green-200" data-color="green"></div>
                    <div class="color-option bg-blue-200" data-color="blue"></div>
                    <div class="color-option bg-pink-200" data-color="pink"></div>
                    <div class="color-option bg-purple-200" data-color="purple"></div>
                </div>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Opacity</label>
                <input type="range" id="highlight-opacity" min="30" max="100" value="50" class="w-full">
                <div class="flex justify-between text-xs text-gray-600">
                    <span>30%</span>
                    <span>65%</span>
                    <span>100%</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // PDF.js setup
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        // Global variables
        // Global variables (add this near the top)
        const colorMap = {
            black: '#000000',
            red: '#FF0000',
            blue: '#0000FF',
            green: '#008000',
            yellow: '#FFFF00',
            purple: '#800080',
            pink: '#FFC0CB',
            gray: '#808080'
        };
        let pdfDoc = null,
            pageNum = 1,
            pageRendering = false,
            pageNumPending = null,
            scale = 1.0,
            canvas = document.getElementById('pdf-canvas'),
            ctx = canvas.getContext('2d'),
            activeTool = null,
            annotations = [],
            selectedAnnotation = null,
            signaturePad = null,
            currentSignatureColor = 'black',
            currentTypedSignatureColor = 'black',
            currentTextProperties = {
                fontFamily: 'Arial',
                fontSize: 14,
                color: 'black', // Default text color is black
                bold: false,
                italic: false,
                underline: false
            },
            currentHighlightProperties = {
                color: 'yellow',
                opacity: 0.5
            };

        // Initialize the editor
        document.addEventListener('DOMContentLoaded', function() {
            // Set up UI event listeners
            setupEventListeners();

            // Initialize signature pad with proper cursor positioning
            const signatureCanvas = document.getElementById('signature-pad');
            signaturePad = new SignaturePad(signatureCanvas, {
                backgroundColor: 'rgba(255, 255, 255, 0)',
                penColor: 'rgb(0, 0, 0)',
                onBegin: function() {
                    // Fix cursor positioning issue
                    const rect = signatureCanvas.getBoundingClientRect();
                    const lastPoint = signaturePad._data[signaturePad._data.length - 2];
                    if (lastPoint) {
                        signaturePad._data[signaturePad._data.length - 1] = {
                            x: (lastPoint.x * rect.width) / signatureCanvas.offsetWidth,
                            y: (lastPoint.y * rect.height) / signatureCanvas.offsetHeight,
                            time: Date.now()
                        };
                    }
                }
            });

            // Resize signature canvas when window resizes
            window.addEventListener('resize', resizeSignatureCanvas);
            resizeSignatureCanvas();

            // Load a default blank state
            renderBlankCanvas();
        });

        function resizeSignatureCanvas() {
            const canvas = document.getElementById('signature-pad');
            const ratio = Math.max(window.devicePixelRatio || 1, 1);
            canvas.width = canvas.offsetWidth * ratio;
            canvas.height = canvas.offsetHeight * ratio;
            canvas.getContext('2d').scale(ratio, ratio);
            if (signaturePad) {
                signaturePad.clear(); // Clear the signature after resize
            }
        }

        function setupEventListeners() {
            // Tool buttons
            document.getElementById('upload-btn').addEventListener('click', function() {
                document.getElementById('file-input').click();
            });

            document.getElementById('file-input').addEventListener('change', handleFileSelect);

            document.getElementById('text-tool').addEventListener('click', function() {
                if (activeTool === 'text') {
                    document.getElementById('text-tool-panel').style.display = 'none';
                    setActiveTool(null);
                } else {
                    setActiveTool('text');
                    showToolPanel('text-tool-panel');
                }
            });

            document.getElementById('signature-tool').addEventListener('click', function() {
                if (activeTool === 'signature') {
                    document.getElementById('signature-tool-panel').style.display = 'none';
                    setActiveTool(null);
                } else {
                    setActiveTool('signature');
                    showToolPanel('signature-tool-panel');
                    document.getElementById('signature-draw-container').classList.remove('hidden');
                    const signatureCanvas = document.getElementById('signature-pad');
                    if (!signaturePad) { // Initialize if not already done
                        signaturePad = new SignaturePad(signatureCanvas, {
                            backgroundColor: 'rgba(255, 255, 255, 0)',
                            penColor: 'rgb(0, 0, 0)',
                             onBegin: function() {
                                 // Fix cursor positioning issue
                                 const rect = signatureCanvas.getBoundingClientRect();
                                 const lastPoint = signaturePad._data[signaturePad._data.length - 2];
                                 if (lastPoint) {
                                     signaturePad._data[signaturePad._data.length - 1] = {
                                         x: (lastPoint.x * rect.width) / signatureCanvas.offsetWidth,
                                         y: (lastPoint.y * rect.height) / signatureCanvas.offsetHeight,
                                         time: Date.now()
                                     };
                                 }
                             }
                         });
                        resizeSignatureCanvas(); // Ensure correct scaling
                     } else {
                         signaturePad.clear(); // Clear previous drawing if any
                     }
                    document.getElementById('signature-type-container').classList.add('hidden');
                    document.getElementById('initials-text').classList.add('hidden');
                    document.getElementById('signature-text').classList.remove('hidden');
                    document.getElementById('draw-signature').classList.add('bg-primary', 'text-white');
                    document.getElementById('type-signature').classList.remove('bg-primary', 'text-white');
                    document.getElementById('initials-btn').classList.remove('bg-primary', 'text-white');
                    setSignatureColor(currentSignatureColor);
                }
            });

            document.getElementById('image-tool').addEventListener('click', function() {
                if (activeTool === 'image') {
                    document.getElementById('image-tool-panel').style.display = 'none';
                    setActiveTool(null);
                } else {
                    setActiveTool('image');
                    showToolPanel('image-tool-panel');
                }
            });

            document.getElementById('highlight-tool').addEventListener('click', function() {
                if (activeTool === 'highlight') {
                    document.getElementById('highlight-tool-panel').style.display = 'none';
                    setActiveTool(null);
                } else {
                    setActiveTool('highlight');
                    showToolPanel('highlight-tool-panel');
                }
            });

            document.getElementById('save-pdf').addEventListener('click', savePDF);

            // Page navigation
            document.getElementById('page-select').addEventListener('change', function() {
                const selectedPage = parseInt(this.value);
                if (pdfDoc && selectedPage !== pageNum) {
                    pageNum = selectedPage;
                    queueRenderPage(pageNum);
                }
            });

            document.getElementById('zoom-in').addEventListener('click', function() {
                if (scale < 3.0 && pdfDoc) { // Only zoom if PDF is loaded
                    scale += 0.25;
                    queueRenderPage(pageNum);
                }
            });

            document.getElementById('zoom-out').addEventListener('click', function() {
                if (scale > 0.5 && pdfDoc) { // Only zoom if PDF is loaded
                    scale -= 0.25;
                    queueRenderPage(pageNum);
                }
            });

            // Click on PDF viewer
            document.getElementById('pdf-viewer').addEventListener('click', function(e) {
                if (!activeTool || !pdfDoc) return; // Don't add annotations if no PDF or tool

                // Check if clicked on an annotation
                const clickedAnnotation = e.target.closest('.annotation');
                if (clickedAnnotation) {
                    // If clicking on editable text, focus it but keep panel open
                    if (clickedAnnotation.querySelector('.editable-text') &&
                        e.target === clickedAnnotation.querySelector('.editable-text')) {
                         selectAnnotation(clickedAnnotation); // Re-select to ensure panel updates
                         return;
                    }

                    // Otherwise select the annotation
                    selectAnnotation(clickedAnnotation);
                    return;
                }

                // Check if clicked on the canvas area (not on an existing annotation or panel)
                 if (!e.target.closest('.tool-panel') && (e.target === canvas || e.target === document.getElementById('pdf-render') ||
                     e.target === document.getElementById('pdf-container'))) {

                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    addAnnotation(x, y);
                     // Don't hide panel or deactivate tool immediately after adding
                     // Deactivation/panel hiding is now handled by the global listener
                }
            });

            // Text tool panel interactions
            document.querySelectorAll('#text-tool-panel .font-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('#text-tool-panel .font-option').forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    currentTextProperties.fontFamily = this.style.fontFamily;
                    updateSelectedAnnotation();
                });
            });

            document.getElementById('text-size').addEventListener('input', function() {
                currentTextProperties.fontSize = parseInt(this.value);
                updateSelectedAnnotation();
            });

            document.querySelectorAll('.color-option').forEach(option => {
                option.addEventListener('click', function() {
                    const panelId = this.closest('.tool-panel')?.id;
                    if (!panelId) return; // Should always find a panel

                    document.querySelectorAll(`#${panelId} .color-option`).forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');

                    const color = this.dataset.color;

                    if (panelId === 'text-tool-panel') {
                        currentTextProperties.color = color;
                         updateSelectedAnnotation(); // Update selected text if any
                    } else if (panelId === 'signature-tool-panel') {
                        if (this.closest('#signature-type-container')) {
                            setTypedSignatureColor(color);
                        } else {
                            setSignatureColor(color);
                        }
                    } else if (panelId === 'highlight-tool-panel') {
                         currentHighlightProperties.color = color;
                         updateSelectedAnnotation(); // Update selected highlight if any
                    }
                });
            });

            document.getElementById('bold-text').addEventListener('click', function() {
                currentTextProperties.bold = !currentTextProperties.bold;
                this.classList.toggle('bg-gray-200');
                updateSelectedAnnotation();
            });

            document.getElementById('italic-text').addEventListener('click', function() {
                currentTextProperties.italic = !currentTextProperties.italic;
                this.classList.toggle('bg-gray-200');
                updateSelectedAnnotation();
            });

            document.getElementById('underline-text').addEventListener('click', function() {
                currentTextProperties.underline = !currentTextProperties.underline;
                this.classList.toggle('bg-gray-200');
                updateSelectedAnnotation();
            });

            // Signature tool panel
            document.getElementById('draw-signature').addEventListener('click', function() {
                document.getElementById('signature-draw-container').classList.remove('hidden');
                document.getElementById('signature-type-container').classList.add('hidden');
                document.getElementById('type-signature').classList.remove('bg-primary', 'text-white');
                document.getElementById('initials-btn').classList.remove('bg-primary', 'text-white');
                this.classList.add('bg-primary', 'text-white');
                resizeSignatureCanvas(); // Ensure canvas is ready
            });

            document.getElementById('type-signature').addEventListener('click', function() {
                document.getElementById('signature-draw-container').classList.add('hidden');
                document.getElementById('signature-type-container').classList.remove('hidden');
                document.getElementById('signature-text').classList.remove('hidden');
                document.getElementById('initials-text').classList.add('hidden');
                document.getElementById('draw-signature').classList.remove('bg-primary', 'text-white');
                document.getElementById('initials-btn').classList.remove('bg-primary', 'text-white');
                this.classList.add('bg-primary', 'text-white');
            });

            document.getElementById('initials-btn').addEventListener('click', function() {
                document.getElementById('signature-draw-container').classList.add('hidden');
                document.getElementById('signature-type-container').classList.remove('hidden');
                document.getElementById('signature-text').classList.add('hidden');
                document.getElementById('initials-text').classList.remove('hidden');
                document.getElementById('draw-signature').classList.remove('bg-primary', 'text-white');
                document.getElementById('type-signature').classList.remove('bg-primary', 'text-white');
                this.classList.add('bg-primary', 'text-white');
            });

            document.getElementById('clear-signature').addEventListener('click', function() {
                if (signaturePad) signaturePad.clear();
                document.getElementById('signature-text').value = '';
                document.getElementById('initials-text').value = '';
            });

            document.getElementById('save-signature').addEventListener('click', function() {
                 const drawContainerVisible = !document.getElementById('signature-draw-container').classList.contains('hidden');

                if (drawContainerVisible && signaturePad && !signaturePad.isEmpty()) {
                    const signatureData = signaturePad.toDataURL();
                    createSignatureAnnotation(signatureData, 'drawing');
                } else if (document.getElementById('initials-text').offsetParent !== null && document.getElementById('initials-text').value) { // Check if initials input is visible and has value
                     const initials = document.getElementById('initials-text').value;
                     createSignatureAnnotation(initials, 'initials'); // color taken from global
                 } else if (document.getElementById('signature-text').offsetParent !== null && document.getElementById('signature-text').value) { // Check if text input is visible and has value
                    const text = document.getElementById('signature-text').value;
                    createSignatureAnnotation(text, 'typed'); // color taken from global
                 } else if (!drawContainerVisible && document.getElementById('initials-text').offsetParent !== null && !document.getElementById('initials-text').value) {
                     alert('Please type your initials.');
                 } else if (!drawContainerVisible && document.getElementById('signature-text').offsetParent !== null && !document.getElementById('signature-text').value) {
                     alert('Please type your signature.');
                 } else if (drawContainerVisible && signaturePad && signaturePad.isEmpty()) {
                    alert('Please draw your signature.');
                 }
                 // Panel hiding is now handled globally
            });

            // Image tool panel
            document.getElementById('browse-images').addEventListener('click', function() {
                document.getElementById('image-input').click();
            });

            document.getElementById('image-input').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        createImageAnnotation(event.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            });

            // Highlight tool panel
            document.getElementById('highlight-opacity').addEventListener('input', function() {
                currentHighlightProperties.opacity = parseInt(this.value) / 100;
                updateSelectedAnnotation();
            });

            // Global click listener to handle deselecting annotations and hiding panels
             document.addEventListener('click', function(e) {
                const clickedAnnotation = e.target.closest('.annotation');
                const clickedPanel = e.target.closest('.tool-panel');
                const clickedToolButton = e.target.closest('.group > button[id$="-tool"]'); // Specifically target tool buttons
                const clickedSaveButton = e.target.closest('#save-pdf');
                 const clickedPanelButton = e.target.closest('.tool-panel button, .tool-panel input, .tool-panel select, .tool-panel .color-option, .tool-panel .font-option');

                 // If the click is outside an annotation, panel, and *any* toolbar button (or save)
                 // Also check if the click was NOT inside a panel control element
                if (!clickedAnnotation && !clickedPanel && !clickedToolButton && !clickedSaveButton && !clickedPanelButton) {
                     if (selectedAnnotation || activeTool) { // Only clear if something *was* selected/active
                           clearSelection(); // Hides panels
                           setActiveTool(null); // Deactivates tool
                      }
                 } else if (clickedAnnotation) {
                    // If clicking on editable text *within the currently selected annotation*
                     if (clickedAnnotation === selectedAnnotation && e.target.classList.contains('editable-text')) {
                        // It's a click *inside* the text box we already have selected, do nothing to panel
                        const annotation = annotations.find(a => a.id === clickedAnnotation.id);
                         if(annotation && annotation.type === 'text') {
                            // Make sure text tool is active and panel visible if somehow hidden
                             if (activeTool !== 'text') setActiveTool('text');
                            showToolPanel('text-tool-panel');
                         }
                    } else {
                         // Otherwise, select the clicked annotation (which might show a different panel)
                         selectAnnotation(clickedAnnotation);
                    }
                 }
                 // Clicks inside panels, on panel controls, or on tool buttons are ignored here, they manage themselves

             }, true); // Use capture phase
        }

        function setSignatureColor(color) {
            currentSignatureColor = color;
            const colorMapLocal = { // Renamed to avoid conflict with global colorMap
                black: '#000000',
                red: '#FF0000',
                blue: '#0000FF',
                green: '#008000'
            };
            if (signaturePad) {
                signaturePad.penColor = colorMapLocal[color]; // Use local map
            }

            // Update selected color indicator
            document.querySelectorAll('#signature-draw-container .color-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.color === color) {
                    opt.classList.add('selected');
                }
            });
        }

        function setTypedSignatureColor(color) {
            currentTypedSignatureColor = color;

            // Update selected color indicator
            document.querySelectorAll('#signature-type-container .color-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.color === color) {
                    opt.classList.add('selected');
                }
            });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const typedArray = new Uint8Array(e.target.result);
                    // Clear existing state before loading new PDF
                    annotations = [];
                    clearSelection();
                    setActiveTool(null);
                    pageNum = 1;
                    scale = 1.0;
                    pdfDoc = null; // Reset pdfDoc

                    loadPDF(typedArray);
                };
                reader.onerror = function(e) {
                    console.error("File reading error:", e);
                    alert('Error reading file.');
                };
                reader.readAsArrayBuffer(file);
            } else if (file) {
                alert('Please select a valid PDF file.');
                 event.target.value = null; // Reset file input
            }
        }

        function loadPDF(data) {
            pdfjsLib.getDocument(data).promise.then(function(pdf) {
                pdfDoc = pdf;

                // Update page select dropdown
                const pageSelect = document.getElementById('page-select');
                pageSelect.innerHTML = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = '' + i; // Just page number
                    pageSelect.appendChild(option);
                }
                 document.getElementById('page-select').value = 1; // Ensure first page selected

                // Render first page
                pageNum = 1; // Explicitly set pageNum to 1
                queueRenderPage(1);
            }).catch(function(error) {
                console.error('Error loading PDF:', error);
                alert('Error loading PDF. The file might be corrupted or invalid.');
                renderBlankCanvas(); // Show blank canvas on error
            });
        }

        function queueRenderPage(num) {
            if (pageRendering) {
                pageNumPending = num;
            } else {
                renderPage(num);
            }
        }

        function renderPage(num) {
            pageRendering = true;
            pageNum = num; // Ensure pageNum is updated

            // Update page select visually
            document.getElementById('page-select').value = num;

            pdfDoc.getPage(num).then(function(page) {
                const viewport = page.getViewport({ scale: scale });
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                // Adjust container div to match canvas size for annotation positioning
                const pdfRenderDiv = document.getElementById('pdf-render');
                pdfRenderDiv.style.width = viewport.width + 'px';
                pdfRenderDiv.style.height = viewport.height + 'px';


                const renderContext = {
                    canvasContext: ctx,
                    viewport: viewport
                };

                const renderTask = page.render(renderContext);

                renderTask.promise.then(function() {
                    pageRendering = false;
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }

                    // Redraw annotations for this page
                    redrawAnnotations();
                }).catch(function(error) {
                    console.error('Error rendering page:', error);
                    pageRendering = false;
                    // Optionally display an error message on the canvas
                });
            }).catch(function(error) {
                console.error('Error getting page:', error);
                pageRendering = false;
            });
        }

        function renderBlankCanvas() {
            canvas.width = 800; // Default width
            canvas.height = 1000; // Default height
             // Reset container size as well
            const pdfRenderDiv = document.getElementById('pdf-render');
            pdfRenderDiv.style.width = canvas.width + 'px';
            pdfRenderDiv.style.height = canvas.height + 'px';

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#555555'; // Dark gray text
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Upload a PDF to start editing', canvas.width / 2, canvas.height / 2 - 20);
             ctx.font = '14px Arial';
             ctx.fillText('(Use the upload button on the left)', canvas.width / 2, canvas.height / 2 + 10);

             // Clear page select
             document.getElementById('page-select').innerHTML = '<option>N/A</option>';
        }

        function setActiveTool(tool) {
            // Deactivate previous tool button styling
             if(activeTool && document.getElementById(`${activeTool}-tool`)) {
                 document.getElementById(`${activeTool}-tool`).classList.remove('active-tool');
             }

            activeTool = tool; // Set the new tool

            // Activate new tool button styling
            if(activeTool && document.getElementById(`${activeTool}-tool`)) {
                 document.getElementById(`${activeTool}-tool`).classList.add('active-tool');
             }

             // Don't clear selection here - let selection logic handle it
        }

        function showToolPanel(panelId) {
             // Hide all tool panels first
             document.querySelectorAll('.tool-panel').forEach(panel => {
                panel.style.display = 'none';
            });
            // Show the specific panel if its ID is provided and a tool is active
             if (panelId && activeTool) { // Ensure a tool is actually active
                 const panel = document.getElementById(panelId);
                 if (panel) panel.style.display = 'block';
            }
        }

        function addAnnotation(x, y) {
            if (!activeTool || !pdfDoc) return; // Prevent adding if no tool or no pdf

            const annotationId = 'annotation-' + Date.now();
            const annotationDiv = document.createElement('div');
            annotationDiv.className = 'annotation';
            annotationDiv.id = annotationId;
            // Block added earlier for new colorMap logic (lines 1001-1035) is REMOVED here
            annotationDiv.style.left = x + 'px';
            annotationDiv.style.top = y + 'px';

            // Set initial size based on tool
            let innerHtml = '';
             let initialHeight = 30; // Default height
            // Applying older logic for 'text' annotation
             if (activeTool === 'text') {
                annotationDiv.style.width = '200px';
                annotationDiv.style.height = '30px'; // Use fixed height from older code
                
                // Create an editable div with auto-focus (older version)
                const editableDiv = document.createElement('div');
                editableDiv.className = 'editable-text';
                editableDiv.contentEditable = true;
                editableDiv.textContent = "Type here";
                editableDiv.style.fontFamily = currentTextProperties.fontFamily;
                editableDiv.style.fontSize = currentTextProperties.fontSize + 'px';
                editableDiv.style.color = currentTextProperties.color; // Older simple color
                editableDiv.style.fontWeight = currentTextProperties.bold ? 'bold' : 'normal';
                editableDiv.style.fontStyle = currentTextProperties.italic ? 'italic' : 'normal';
                editableDiv.style.textDecoration = currentTextProperties.underline ? 'underline' : 'none';
                
                // Focus immediately
                setTimeout(() => {
                    editableDiv.focus();
                    // Move cursor to end
                    const range = document.createRange();
                    range.selectNodeContents(editableDiv);
                    range.collapse(false);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }, 0);
                
                // Update content when changed
                editableDiv.addEventListener('input', function() {
                    const annotation = annotations.find(a => a.id === annotationId);
                    if (annotation) {
                        annotation.content = editableDiv.textContent;
                    }
                });
                
                innerHtml = '';
                annotationDiv.appendChild(editableDiv);
            } else if (activeTool === 'highlight') {
                 annotationDiv.style.width = '100px';
                 initialHeight = 20; // Fixed height for highlight
                annotationDiv.style.height = initialHeight + 'px';
                 let colorRgba = `rgba(255, 255, 0, ${currentHighlightProperties.opacity})`; // Default yellow
                 switch(currentHighlightProperties.color) {
                    case 'green': colorRgba = `rgba(0, 255, 0, ${currentHighlightProperties.opacity})`; break;
                    case 'blue': colorRgba = `rgba(0, 0, 255, ${currentHighlightProperties.opacity})`; break;
                    case 'pink': colorRgba = `rgba(255, 192, 203, ${currentHighlightProperties.opacity})`; break;
                    case 'purple': colorRgba = `rgba(128, 0, 128, ${currentHighlightProperties.opacity})`; break;
                 }
                 annotationDiv.style.backgroundColor = colorRgba;
                 annotationDiv.style.zIndex = 4; // Place highlights slightly below text/signatures if needed
            } else if (activeTool === 'signature') {
                // Placeholder size, will be adjusted by signature logic later if needed
                annotationDiv.style.width = '200px';
                 initialHeight = 80; // Default for drawing signature
                 annotationDiv.style.height = initialHeight + 'px';
                 // The actual signature content is added by createSignatureAnnotation
                 // We don't add this placeholder div directly here for signatures.
                 console.warn("addAnnotation called for signature - should be handled by createSignatureAnnotation");
                 return; // Exit early, signature is handled differently
             } else if (activeTool === 'image') {
                 // Placeholder size, will be adjusted by image logic later if needed
                 annotationDiv.style.width = '200px';
                 initialHeight = 150; // Default guess for image, will adjust on load
                 annotationDiv.style.height = initialHeight + 'px';
                 // Image content is handled by createImageAnnotation
                 console.warn("addAnnotation called for image - should be handled by createImageAnnotation");
                 return; // Exit early, image is handled differently
            }

            // Add delete button (common to text and highlight added here)
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = function(event) {
                event.stopPropagation(); // Prevent selection change
                deleteAnnotation(annotationDiv);
            };
            annotationDiv.appendChild(deleteBtn);

            // Set up drag and resize
            setupDraggable(annotationDiv);

            document.getElementById('pdf-container').appendChild(annotationDiv);

            // Store annotation data
            const annotation = {
                id: annotationId,
                type: activeTool,
                page: pageNum,
                x: x,
                y: y,
                width: parseInt(annotationDiv.style.width),
                height: activeTool === 'text' ? 30 : initialHeight, // Use fixed height for text from older code
                properties: activeTool === 'text' ? {...currentTextProperties} :
                           activeTool === 'highlight' ? {...currentHighlightProperties} : null,
                content: activeTool === 'text' ? 'Type here' : null // Initial text content
                 // Signature/Image content added separately
            };

            annotations.push(annotation);

            // Select the new annotation (this will also handle showing the correct panel)
            selectAnnotation(annotationDiv);

            // For text, make sure the panel is shown and properties match
             if (activeTool === 'text') {
                 setActiveTool('text'); // Ensure tool is active
                 showToolPanel('text-tool-panel'); // Ensure panel is visible
                 // Update panel to match current properties (should already match, but good practice)
                 updateTextPanelControls(currentTextProperties);
             } else if (activeTool === 'highlight') {
                 setActiveTool('highlight');
                 showToolPanel('highlight-tool-panel');
                 updateHighlightPanelControls(currentHighlightProperties);
            }
        }

        function createSignatureAnnotation(content, type) {
             if (!pdfDoc) return; // Don't add if no PDF loaded

             const signatureId = 'signature-' + Date.now();
             const signatureDiv = document.createElement('div');
             signatureDiv.className = 'annotation';
             signatureDiv.id = signatureId;

            let sigWidth = 200;
             let sigHeight = (type === 'drawing') ? 80 : 60;

            signatureDiv.style.width = sigWidth + 'px';
             signatureDiv.style.height = sigHeight + 'px';
            signatureDiv.style.cursor = 'move';

            // Center the signature on the canvas view
             const containerRect = document.getElementById('pdf-render').getBoundingClientRect();
             const x = containerRect.width / 2 - (sigWidth / 2);
             const y = containerRect.height / 2 - (sigHeight / 2);
             // Ensure position is within bounds
            signatureDiv.style.left = Math.max(0, x) + 'px';
            signatureDiv.style.top = Math.max(0, y) + 'px';

             // Add content based on type
             if (type === 'drawing') {
                 signatureDiv.innerHTML = `<img src="${content}" style="width:100%; height:100%; object-fit: contain; display: block;" />`; // Added object-fit and display block
             } else if (type === 'typed' || type === 'initials') {
                const font = document.getElementById('signature-font').value;
                 const textColor = currentTypedSignatureColor; // Use the global for typed
                const colorMapLocal = { // Use local map here too
                    black: '#000000', red: '#FF0000', blue: '#0000FF', green: '#008000', purple: '#800080'
                 };
                 signatureDiv.innerHTML = `<div style="font-family:${font}; color:${colorMapLocal[textColor]}; font-size:${type === 'initials' ? '32px' : '24px'}; width:100%; height:100%; display:flex; align-items:center; justify-content:center; white-space: nowrap; box-sizing: border-box; overflow: hidden;">${content}</div>`;
             }

            // Add delete button consistently
             const deleteBtn = document.createElement('div');
             deleteBtn.className = 'delete-btn';
             deleteBtn.innerHTML = '&times;';
             deleteBtn.onclick = function(event) {
                event.stopPropagation(); // Prevent triggering other click listeners
                deleteAnnotation(signatureDiv);
             };
             signatureDiv.appendChild(deleteBtn);

            // Set up drag and resize
            setupDraggable(signatureDiv);

            document.getElementById('pdf-container').appendChild(signatureDiv);

            // Store annotation data
            const annotation = {
                id: signatureId,
                type: 'signature',
                signatureType: type,
                page: pageNum,
                 x: parseFloat(signatureDiv.style.left), // Store numerical position
                 y: parseFloat(signatureDiv.style.top),
                 width: sigWidth, // Store initial width
                 height: sigHeight, // Store initial height
                content: content,
                 properties: (type === 'typed' || type === 'initials') ? {
                     font: document.getElementById('signature-font').value,
                     color: currentTypedSignatureColor // Store the typed color specifically
                } : null
            };

            annotations.push(annotation);

            // Select the new signature
            selectAnnotation(signatureDiv);

            // Clear signature inputs
             if (signaturePad) signaturePad.clear();
            document.getElementById('signature-text').value = '';
            document.getElementById('initials-text').value = '';

            // Close panel and deactivate tool
             // document.getElementById('signature-tool-panel').style.display = 'none'; // Global handler does this
             // setActiveTool(null); // Global handler does this
        }

        function createImageAnnotation(imageData) {
             if (!pdfDoc) return; // Don't add if no PDF loaded

            const imageId = 'image-' + Date.now();
            const imageDiv = document.createElement('div');
            imageDiv.className = 'annotation';
            imageDiv.id = imageId;

            // Set initial size and position
             let initialWidth = 200;
            imageDiv.style.width = initialWidth + 'px';
             imageDiv.style.height = 'auto'; // Let image load determine initial height

            // Center the image on the canvas view
            const containerRect = document.getElementById('pdf-render').getBoundingClientRect();
            const x = containerRect.width / 2 - (initialWidth / 2);
            const y = containerRect.height / 2 - 100; // Adjust initial Y placement maybe?
             imageDiv.style.left = Math.max(0, x) + 'px';
            imageDiv.style.top = Math.max(0, y) + 'px';

            // Add image content
            const img = document.createElement('img');
            img.src = imageData;
            img.style.width = '100%';
            img.style.height = 'auto'; // Maintain aspect ratio
             img.style.display = 'block'; // Prevent extra space below image
             img.style.userSelect = 'none'; // Prevent image dragging issues

            imageDiv.innerHTML = '';
            imageDiv.appendChild(img);

            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '&times;';
             deleteBtn.onclick = function(event) {
                event.stopPropagation();
                 deleteAnnotation(imageDiv);
             };
            imageDiv.appendChild(deleteBtn);

             // Store annotation data (with placeholders until loaded)
             const annotation = {
                 id: imageId,
                 type: 'image',
                 page: pageNum,
                 x: parseFloat(imageDiv.style.left),
                 y: parseFloat(imageDiv.style.top),
                 width: initialWidth,
                 height: 'auto', // Update after load
                 content: imageData
             };

            // Set up image load logic BEFORE adding to DOM
            img.onload = function() {
                const aspectRatio = img.naturalWidth / img.naturalHeight;
                 if (!aspectRatio || !isFinite(aspectRatio)) {
                     console.warn("Invalid aspect ratio for image:", img.src);
                     // Use a default height if aspect ratio is invalid
                     imageDiv.style.height = '150px'; // Default fallback height
                } else {
                     const initialHeight = initialWidth / aspectRatio;
                     imageDiv.style.height = initialHeight + 'px';
                }

                 // Update stored annotation height and width (now definite)
                 const storedAnnotation = annotations.find(a => a.id === imageId);
                 if (storedAnnotation) {
                     storedAnnotation.height = parseFloat(imageDiv.style.height);
                     storedAnnotation.width = initialWidth;
                }

                 // Now add to DOM and setup draggable/observer *after* initial size is known
                 document.getElementById('pdf-container').appendChild(imageDiv);
                 setupDraggable(imageDiv); // Must be called after appending

                // Setup resize observer *after* imageDiv is in the DOM and has size
                 new ResizeObserver(() => {
                     if (!img.naturalWidth || !img.naturalHeight) return; // Skip if natural dims aren't available
                     const currentWidth = imageDiv.offsetWidth;
                     const aspectRatio = img.naturalWidth / img.naturalHeight;
                      if (aspectRatio && isFinite(aspectRatio)) {
                          imageDiv.style.height = (currentWidth / aspectRatio) + 'px'; // Maintain aspect ratio on resize
                     }
                     // Update stored annotation width/height on resize
                     const anno = annotations.find(a => a.id === imageId);
                     if (anno) {
                        anno.width = currentWidth;
                         anno.height = imageDiv.offsetHeight;
                     }
                 }).observe(imageDiv);

                 // Select the new image
                 selectAnnotation(imageDiv);
            };
             img.onerror = function() {
                 console.error("Failed to load image for annotation:", img.src);
                 // Maybe remove the annotation placeholder or show an error
                 // Remove the potentially broken annotation data
                 annotations = annotations.filter(a => a.id !== imageId);
            };

            // Add annotation data, wait for onload to add element/setup drag/resize/select
             annotations.push(annotation);

            // Clear file input
            document.getElementById('image-input').value = '';
            // Close panel and deactivate tool
            // document.getElementById('image-tool-panel').style.display = 'none'; // Global handler
            // setActiveTool(null); // Global handler
        }

        function setupDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;
            let isResizing = false;

            element.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e = e || window.event;
                 // Prevent triggering document click listener (for panel closing) or canvas click (for adding new items)
                 e.stopPropagation();
                // Prevent text selection/image dragging only if dragging/resizing starts
                // e.preventDefault(); // Delay this

                // Check if we're clicking on the resize handle (bottom-right corner)
                const rect = element.getBoundingClientRect();
                const resizeHandleSize = 15; // Size of the clickable resize area
                const resizeHandleClicked =
                    e.clientX >= rect.right - resizeHandleSize && e.clientX <= rect.right &&
                    e.clientY >= rect.bottom - resizeHandleSize && e.clientY <= rect.bottom;

                if (resizeHandleClicked && element.style.resize !== 'none') { // Check if resizing is allowed
                    isResizing = true;
                    isDragging = false; // Ensure not dragging
                    element.style.cursor = 'nwse-resize';
                    e.preventDefault(); // Prevent selection/dragging now
                } else {
                    isResizing = false;
                    isDragging = true; // Assume dragging if not resizing
                    element.style.cursor = 'move'; // Ensure move cursor if not resizing
                     // Don't preventDefault here immediately, allow text selection inside if not moved
                }

                // Get the mouse cursor position at startup
                pos3 = e.clientX;
                pos4 = e.clientY;

                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e = e || window.event;

                if (isResizing) {
                    e.preventDefault(); // Prevent selection during resize
                    // Calculate new width and height based on mouse movement
                    const dx = e.clientX - pos3;
                    const dy = e.clientY - pos4;

                    const currentWidth = element.offsetWidth;
                    const currentHeight = element.offsetHeight;

                    let newWidth = currentWidth + dx;
                    let newHeight = currentHeight + dy;

                    const minWidth = 50; // Minimum dimensions
                    const minHeight = 20;

                    newWidth = Math.max(minWidth, newWidth);
                    newHeight = Math.max(minHeight, newHeight);

                    element.style.width = newWidth + 'px';

                    // Maintain aspect ratio for images during resize
                    const img = element.querySelector('img');
                     if (img && img.naturalWidth && img.naturalHeight) {
                         const aspectRatio = img.naturalWidth / img.naturalHeight;
                         newHeight = newWidth / aspectRatio; // Adjust height based on width
                         element.style.height = Math.max(minHeight, newHeight) + 'px';
                     } else {
                         // For non-image or non-aspect-ratio elements, allow free resize
                         element.style.height = newHeight + 'px';
                    }

                     // Update start positions for next move calculation
                     pos3 = e.clientX;
                     pos4 = e.clientY;

                } else if (isDragging) {
                     // Only prevent default and start dragging if mouse actually moved
                     if (Math.abs(e.clientX - pos3) > 2 || Math.abs(e.clientY - pos4) > 2) {
                         e.preventDefault(); // Prevent text selection once dragging starts

                        // Calculate the new cursor position
                        pos1 = pos3 - e.clientX;
                        pos2 = pos4 - e.clientY;
                        pos3 = e.clientX;
                        pos4 = e.clientY;

                        // Set the element's new position
                         let newTop = element.offsetTop - pos2;
                         let newLeft = element.offsetLeft - pos1;

                         // // Optional: Constrain within parent bounds (pdf-container)
                         // const parentRect = element.parentElement.getBoundingClientRect();
                         // const elemRect = element.getBoundingClientRect();
                         // newLeft = Math.max(0, Math.min(newLeft, parentRect.width - element.offsetWidth));
                         // newTop = Math.max(0, Math.min(newTop, parentRect.height - element.offsetHeight));


                        element.style.top = newTop + "px";
                        element.style.left = newLeft + "px";
                     }
                }

                // Update annotation position/size in the array (throttle/debounce recommended for high frequency)
                updateAnnotationData(element);
            }

            function closeDragElement() {
                // Stop moving/resizing when mouse button is released
                document.onmouseup = null;
                document.onmousemove = null;
                element.style.cursor = 'move'; // Reset cursor
                isDragging = false;
                isResizing = false;

                 // Final update of annotation data
                 updateAnnotationData(element);
            }

            function updateAnnotationData(el) {
                const annotation = annotations.find(a => a.id === el.id);
                if (annotation) {
                    annotation.x = el.offsetLeft;
                    annotation.y = el.offsetTop;
                    annotation.width = el.offsetWidth;
                    annotation.height = el.offsetHeight;
                    // If it's text, update content too (as it might change height)
                    if (annotation.type === 'text') {
                        const editableDiv = el.querySelector('.editable-text');
                        if (editableDiv) {
                            annotation.content = editableDiv.textContent;
                        }
                    }
                }
            }
        }

        // Helper function to update text panel controls based on properties object
        function updateTextPanelControls(properties) {
             // Font Family
             document.querySelectorAll('#text-tool-panel .font-option').forEach(opt => {
                 opt.classList.remove('selected');
                 // Need a robust way to compare font families, simple string compare might fail due to quotes/spacing
                 const targetFont = properties.fontFamily.replace(/['"]/g, '').toLowerCase();
                 const optionFont = opt.style.fontFamily.replace(/['"]/g, '').toLowerCase();
                 if (optionFont.includes(targetFont) || targetFont.includes(optionFont)) { // Allow partial match
                     opt.classList.add('selected');
                 }
             });
             if (!document.querySelector('#text-tool-panel .font-option.selected')) {
                 // Fallback to selecting Arial if current font not found
                 document.querySelector('#text-tool-panel .font-option[style*="Arial"]')?.classList.add('selected');
             }
             // Font Size
             document.getElementById('text-size').value = properties.fontSize;
             // Color
             document.querySelectorAll('#text-tool-panel .color-option').forEach(opt => {
                 opt.classList.toggle('selected', opt.dataset.color === properties.color);
             });
             // Styles
             document.getElementById('bold-text').classList.toggle('bg-gray-200', properties.bold);
             document.getElementById('italic-text').classList.toggle('bg-gray-200', properties.italic);
             document.getElementById('underline-text').classList.toggle('bg-gray-200', properties.underline);
        }

         // Helper function to update highlight panel controls
         function updateHighlightPanelControls(properties) {
             document.querySelectorAll('#highlight-tool-panel .color-option').forEach(opt => {
                 opt.classList.toggle('selected', opt.dataset.color === properties.color);
             });
             document.getElementById('highlight-opacity').value = properties.opacity * 100;
         }


        function selectAnnotation(annotationElement) {
             if (!annotationElement) {
                 clearSelection();
                 return;
             }
             // If clicking the already selected annotation's text, do nothing extra
             if (selectedAnnotation === annotationElement && event.target.classList.contains('editable-text')) {
                 return;
             }
              // If clicking the same annotation again, don't re-process unless it's text focus
              if (selectedAnnotation === annotationElement) {
                  return;
              }


            // Clear previous selection (will also hide old panel)
            clearSelection();

            // Set new selection
            annotationElement.classList.add('selected');
            selectedAnnotation = annotationElement;

            // Update properties panel based on the newly selected annotation
            const annotation = annotations.find(a => a.id === annotationElement.id);
            if (!annotation) return;

             // Determine which tool and panel correspond to the annotation type
             let toolToActivate = null;
             let panelToShow = null;

             switch (annotation.type) {
                 case 'text':
                     toolToActivate = 'text';
                     panelToShow = 'text-tool-panel';
                     setActiveTool(toolToActivate); // Activate the tool
                     showToolPanel(panelToShow);   // Show the panel
                     updateTextPanelControls(annotation.properties); // Update controls
                     currentTextProperties = {...annotation.properties}; // Sync global state
                     break;
                 // Block related to the newer text logic REMOVED
                 case 'highlight':
                     toolToActivate = 'highlight';
                     panelToShow = 'highlight-tool-panel';
                     setActiveTool(toolToActivate);
                     showToolPanel(panelToShow);
                     updateHighlightPanelControls(annotation.properties);
                     currentHighlightProperties = {...annotation.properties}; // Sync global state
                     break;
                 case 'signature':
                     // Selecting a signature doesn't usually open the creation panel
                     // No panel to show, maybe deactivate current tool? Or keep active tool?
                     // Let's deactivate the tool for now when selecting existing signature/image
                      // setActiveTool(null); // Or keep the current tool active? Let's try keeping it active.
                      // showToolPanel(null); // Hide panels
                     break;
                 case 'image':
                      // Similar to signature, selecting doesn't open the 'add image' panel
                      // setActiveTool(null);
                      // showToolPanel(null);
                     break;
                 default:
                     // Unknown type, clear tool and panel
                     setActiveTool(null);
                     showToolPanel(null);
                     break;
             }
        }

        function clearSelection() {
            if(selectedAnnotation) { // Only remove class if something was selected
                 selectedAnnotation.classList.remove('selected');
             }
            selectedAnnotation = null;
            // Hide all tool panels when clearing selection (unless a tool remains active)
             if (!activeTool) {
                 document.querySelectorAll('.tool-panel').forEach(panel => panel.style.display = 'none');
            }
        }

        function updateSelectedAnnotation() {
            if (!selectedAnnotation) return;

            const annotation = annotations.find(a => a.id === selectedAnnotation.id);
            if (!annotation) return;

            // Apply older version logic for text update
            if (annotation.type === 'text') {
                 // Update the properties in the annotation object
                 annotation.properties = {...currentTextProperties};
                 
                 // Update the visual appearance
                 const editableDiv = selectedAnnotation.querySelector('.editable-text');
                 if (editableDiv) {
                     const fontWeight = currentTextProperties.bold ? 'bold' : 'normal';
                     const fontStyle = currentTextProperties.italic ? 'italic' : 'normal';
                     const textDecoration = currentTextProperties.underline ? 'underline' : 'none';
                     
                     editableDiv.style.fontFamily = currentTextProperties.fontFamily;
                     editableDiv.style.fontSize = currentTextProperties.fontSize + 'px';
                     editableDiv.style.color = currentTextProperties.color; // Older simple color
                     editableDiv.style.fontWeight = fontWeight;
                     editableDiv.style.fontStyle = fontStyle;
                     editableDiv.style.textDecoration = textDecoration;
                 }
            } else if (annotation.type === 'highlight') {
                // Update the properties in the annotation object
                annotation.properties = {...currentHighlightProperties};

                // Update the visual appearance
                 let colorRgba = 'rgba(255, 255, 0, 0.5)'; // Default
                 switch(currentHighlightProperties.color) {
                    case 'green': colorRgba = `rgba(75, 181, 67, ${currentHighlightProperties.opacity})`; break; // Tailwind green-500 ish
                    case 'blue': colorRgba = `rgba(59, 130, 246, ${currentHighlightProperties.opacity})`; break; // Tailwind blue-500 ish
                    case 'pink': colorRgba = `rgba(236, 72, 153, ${currentHighlightProperties.opacity})`; break; // Tailwind pink-500 ish
                    case 'purple': colorRgba = `rgba(139, 92, 246, ${currentHighlightProperties.opacity})`; break; // Tailwind purple-500 ish
                     case 'yellow': colorRgba = `rgba(253, 224, 71, ${currentHighlightProperties.opacity})`; break; // Tailwind yellow-400 ish
                }
                selectedAnnotation.style.backgroundColor = colorRgba;
            }
            // No updates needed for signature/image appearance based on panels shown here
        }

        function deleteAnnotation(element) {
            if (!element || !element.id) return;
            const annotationId = element.id;

            // Remove from DOM
            element.remove();

            // Remove from annotations array
            annotations = annotations.filter(a => a.id !== annotationId);

            // Clear selection if this was the selected annotation
            if (selectedAnnotation && selectedAnnotation.id === annotationId) {
                clearSelection();
                 // If deleting the item also means stopping the current tool action
                 // setActiveTool(null); // This is handled by global click now
            }
        }

        function redrawAnnotations() {
             // Get the container for annotations
             const container = document.getElementById('pdf-container');
             if (!container) return;

             // Cache existing DOM annotation elements by ID
             const existingElements = {};
             container.querySelectorAll('.annotation').forEach(el => {
                 if (el.id) existingElements[el.id] = el;
                // Incorrectly inserted block (lines 1707-1736 originally) is REMOVED here
             });

             // Process annotations for the current page
             annotations.forEach(annotation => {
                 if (annotation.page !== pageNum) {
                     // If annotation is not for current page, remove its DOM element if it exists
                     if (existingElements[annotation.id]) {
                         existingElements[annotation.id].remove();
                         delete existingElements[annotation.id]; // Remove from cache
                     }
                     return; // Skip to next annotation
                 }

                 let annotationDiv = existingElements[annotation.id];

                 if (annotationDiv) {
                     // Annotation element already exists, maybe update position/size?
                     // For now, we assume full redraw logic is needed or position hasn't changed drastically on zoom/pan
                     // If performance becomes an issue, optimize this to only update styles/content
                     annotationDiv.remove(); // Remove old one, create new one below
                 }

                // Create the annotation element
                annotationDiv = document.createElement('div');
                annotationDiv.className = 'annotation';
                annotationDiv.id = annotation.id;
                 annotationDiv.style.left = annotation.x + 'px';
                 annotationDiv.style.top = annotation.y + 'px';
                 annotationDiv.style.width = annotation.width + 'px';
                annotationDiv.style.height = (typeof annotation.height === 'number' && annotation.height > 0) ? annotation.height + 'px' : 'auto';

                 // Common delete button
                 const deleteBtn = document.createElement('div');
                 deleteBtn.className = 'delete-btn';
                 deleteBtn.innerHTML = '&times;';
                 deleteBtn.onclick = function(event) { event.stopPropagation(); deleteAnnotation(annotationDiv); };


                 // Type-specific content and styling
                // Apply older logic for 'text' annotation
                 if (annotation.type === 'text') {
                     const fontWeight = annotation.properties.bold ? 'bold' : 'normal';
                     const fontStyle = annotation.properties.italic ? 'italic' : 'normal';
                     const textDecoration = annotation.properties.underline ? 'underline' : 'none';
                     
                     const editableDiv = document.createElement('div');
                     editableDiv.className = 'editable-text';
                     editableDiv.contentEditable = true;
                     editableDiv.textContent = annotation.content || 'Type here';
                     editableDiv.style.fontFamily = annotation.properties.fontFamily;
                     editableDiv.style.fontSize = annotation.properties.fontSize + 'px';
                     editableDiv.style.color = annotation.properties.color; // Older simple color logic
                     editableDiv.style.fontWeight = fontWeight;
                     editableDiv.style.fontStyle = fontStyle;
                     editableDiv.style.textDecoration = textDecoration;
                     
                     // Update content when changed
                     editableDiv.addEventListener('input', function() {
                         const anno = annotations.find(a => a.id === annotation.id);
                         if (anno) {
                             anno.content = editableDiv.textContent;
                         }
                     });
                     
                     annotationDiv.appendChild(editableDiv);
                    annotationDiv.appendChild(deleteBtn); // Add delete button back
                 } else if (annotation.type === 'highlight') {
                     const props = annotation.properties;
                     const opacity = props.opacity || 0.5;
                     let colorRgba = `rgba(253, 224, 71, ${opacity})`; // Tailwind yellow-400 ish default
                     switch (props.color) {
                         case 'green': colorRgba = `rgba(75, 181, 67, ${opacity})`; break;
                         case 'blue': colorRgba = `rgba(59, 130, 246, ${opacity})`; break;
                         case 'pink': colorRgba = `rgba(236, 72, 153, ${opacity})`; break;
                         case 'purple': colorRgba = `rgba(139, 92, 246, ${opacity})`; break;
                     }
                     annotationDiv.style.backgroundColor = colorRgba;
                     annotationDiv.style.zIndex = 4; // Ensure highlights are below text/signatures
                     annotationDiv.appendChild(deleteBtn);

                 } else if (annotation.type === 'signature') {
                     if (annotation.signatureType === 'drawing') {
                         annotationDiv.innerHTML = `<img src="${annotation.content}" style="width:100%; height:100%; object-fit: contain; display: block; user-select: none;" />`;
                     } else { // Typed or Initials
                         const props = annotation.properties;
                         const colorMapLocal = { black: '#000000', red: '#FF0000', blue: '#0000FF', green: '#008000', purple: '#800080' }; // Use local map
                         const color = props?.color || 'black';
                         annotationDiv.innerHTML = `<div style="font-family:${props?.font || 'Arial'};
                                                 color:${colorMapLocal[color] || '#000000'};
                                                 font-size:${annotation.signatureType === 'initials' ? '32px' : '24px'};
                                                 width:100%; height:100%;
                                                 display:flex; align-items:center; justify-content:center;
                                                 white-space: nowrap; overflow: hidden; box-sizing: border-box; user-select: none;">${annotation.content}</div>`;
                     }
                     annotationDiv.appendChild(deleteBtn); // Add delete button after setting innerHTML

                 } else if (annotation.type === 'image') {
                     const img = document.createElement('img');
                     img.src = annotation.content;
                     img.style.width = '100%';
                     img.style.height = '100%'; // Let parent div control size via object-fit
                     img.style.display = 'block';
                     img.style.objectFit = 'contain'; // Use contain to preserve aspect ratio within the div bounds
                     img.style.userSelect = 'none';

                     annotationDiv.innerHTML = ''; // Clear potential old content
                     annotationDiv.appendChild(img);
                     annotationDiv.appendChild(deleteBtn);

                      // Ensure correct height is applied after image potentially loads again if 'auto' was used
                     img.onload = () => {
                         if (annotationDiv.style.height === 'auto') {
                             const aspectRatio = img.naturalWidth / img.naturalHeight;
                              if (aspectRatio && isFinite(aspectRatio)) {
                                  annotationDiv.style.height = (annotationDiv.offsetWidth / aspectRatio) + 'px';
                                  annotation.height = annotationDiv.offsetHeight; // Update stored height
                              } else {
                                  annotationDiv.style.height = '150px'; // Fallback
                                  annotation.height = 150;
                              }
                         }
                     };
                     img.onerror = () => {
                         console.error("Failed to reload image:", img.src);
                         annotationDiv.innerHTML = 'Error loading image'; // Show error in place
                         annotationDiv.appendChild(deleteBtn);
                     }
                 }

                 // Set up drag and resize AFTER element is fully configured
                 setupDraggable(annotationDiv);

                 container.appendChild(annotationDiv);

                 // Re-select if this was the selected annotation
                 if (selectedAnnotation && selectedAnnotation.id === annotation.id) {
                     annotationDiv.classList.add('selected');
                     selectedAnnotation = annotationDiv; // Update reference to the new DOM element
                 }

                 // Remove from cache as it's processed
                 if (existingElements[annotation.id]) {
                     delete existingElements[annotation.id];
                 }
             });

             // Remove any leftover elements from the DOM that are no longer in the annotations list for this page
             Object.values(existingElements).forEach(el => el.remove());
        }

        async function savePDF() {
            if (!pdfDoc) {
                alert('No PDF loaded to save.');
                return;
            }

            const saveBtn = document.getElementById('save-pdf');
            const originalIcon = saveBtn.innerHTML;
            saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            saveBtn.disabled = true;

            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    unit: 'pt', // Use points, as PDF coordinates are usually in points
                    compress: true
                });

                const originalFilename = document.getElementById('file-input').files[0]?.name || 'edited-document.pdf';
                const newFilename = originalFilename.replace(/\.pdf$/i, '-edited.pdf');


                const loadImage = (src) => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = (err) => { console.error("Image load error:", src, err); reject(new Error('Failed to load image: ' + src)); };
                        img.src = src;
                    });
                };

                 // Use a temporary canvas for drawing annotations to avoid CORS issues with toDataURL on the main canvas if PDF is cross-origin
                 const tempCanvas = document.createElement('canvas');
                 const tempCtx = tempCanvas.getContext('2d');

                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    console.log(`Processing page ${i}`);
                    const page = await pdfDoc.getPage(i);
                     // Render at scale 1.0 for saving
                     const viewport = page.getViewport({ scale: 1.0 });

                    tempCanvas.width = viewport.width;
                    tempCanvas.height = viewport.height;

                    // Render PDF page onto temp canvas
                    const renderContext = {
                        canvasContext: tempCtx,
                        viewport: viewport
                    };
                    await page.render(renderContext).promise;
                    console.log(` Page ${i} rendered to temp canvas`);

                    // Draw annotations for this page onto the temp canvas
                    const pageAnnotations = annotations.filter(a => a.page === i);
                    console.log(` Found ${pageAnnotations.length} annotations for page ${i}`);

                     // Process annotations sequentially to avoid race conditions with canvas context
                     for (const annotation of pageAnnotations) {
                         // Coordinates are assumed to be relative to the canvas at display 'scale'
                         // We need to map them to the save scale (1.0)
                         const scaledX = annotation.x / scale;
                         const scaledY = annotation.y / scale;
                         const scaledWidth = annotation.width / scale;
                         // Height might be 'auto' or number
                         let scaledHeight = (typeof annotation.height === 'number') ? annotation.height / scale : 0;
                         const scaledFontSize = (annotation.properties?.fontSize || 14) / scale;

                        console.log(` Drawing annotation ${annotation.id} (type: ${annotation.type}) at [${scaledX.toFixed(2)}, ${scaledY.toFixed(2)}], size [${scaledWidth.toFixed(2)}, ${scaledHeight > 0 ? scaledHeight.toFixed(2) : 'auto'}]`);

                         try {
                             tempCtx.save(); // Save context state before drawing each annotation

                             if (annotation.type === 'text') {
                                const props = annotation.properties;
                                const fontWeight = props.bold ? 'bold ' : '';
                                const fontStyle = props.italic ? 'italic ' : '';
                                const fontFamily = props.fontFamily || 'Arial'; // Ensure fallback font
                                const lines = (annotation.content || '').split('\n');
                                const lineHeight = scaledFontSize * 1.2; // Approximate line height

                                // Calculate text height more accurately if needed (scaledHeight might be from div)
                                if (scaledHeight <= 0) scaledHeight = lines.length * lineHeight;

                                tempCtx.font = `${fontWeight}${fontStyle}${scaledFontSize}px ${fontFamily}`;
                                tempCtx.fillStyle = props.color || 'black';
                                tempCtx.textBaseline = 'top'; // Align text drawing

                                let currentY = scaledY;
                                lines.forEach(line => {
                                    tempCtx.fillText(line, scaledX, currentY);

                                    // Apply underline after filling text
                                    if (props.underline) {
                                        const textWidth = tempCtx.measureText(line).width;
                                         const underlineY = currentY + scaledFontSize + 1; // Position below baseline
                                        tempCtx.beginPath();
                                        tempCtx.strokeStyle = tempCtx.fillStyle; // Use same color for underline
                                         tempCtx.lineWidth = Math.max(0.5, 1 / scale); // Thin underline, min 0.5pt
                                        tempCtx.moveTo(scaledX, underlineY);
                                        tempCtx.lineTo(scaledX + textWidth, underlineY);
                                        tempCtx.stroke();
                                    }
                                    currentY += lineHeight;
                                });

                            } else if (annotation.type === 'highlight') {
                                 if (scaledHeight <= 0) scaledHeight = 20 / scale; // Default height if unknown
                                const props = annotation.properties;
                                const opacity = props.opacity || 0.5;
                                let colorRgba = `rgba(253, 224, 71, ${opacity})`; // Yellow default
                                 switch (props.color) {
                                    case 'green': colorRgba = `rgba(75, 181, 67, ${opacity})`; break;
                                    case 'blue': colorRgba = `rgba(59, 130, 246, ${opacity})`; break;
                                    case 'pink': colorRgba = `rgba(236, 72, 153, ${opacity})`; break;
                                    case 'purple': colorRgba = `rgba(139, 92, 246, ${opacity})`; break;
                                 }
                                tempCtx.fillStyle = colorRgba;
                                tempCtx.globalAlpha = opacity; // Apply opacity this way too
                                tempCtx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                                tempCtx.globalAlpha = 1.0; // Reset global alpha


                             } else if (annotation.type === 'signature' && annotation.signatureType === 'drawing') {
                                 if (scaledHeight <= 0) scaledHeight = 80 / scale; // Default height
                                 const img = await loadImage(annotation.content);
                                 tempCtx.drawImage(img, scaledX, scaledY, scaledWidth, scaledHeight);

                             } else if (annotation.type === 'image') {
                                 const img = await loadImage(annotation.content);
                                 // If height wasn't determined, calculate from aspect ratio now
                                 if (scaledHeight <= 0 && img.naturalWidth && img.naturalHeight) {
                                     const aspectRatio = img.naturalWidth / img.naturalHeight;
                                     scaledHeight = scaledWidth / aspectRatio;
                                     if (!isFinite(scaledHeight)) scaledHeight = 150 / scale; // Fallback
                                 } else if (scaledHeight <= 0) {
                                     scaledHeight = 150 / scale; // Fallback if natural dims missing
                                 }
                                 tempCtx.drawImage(img, scaledX, scaledY, scaledWidth, scaledHeight);

                             } else if (annotation.type === 'signature' && (annotation.signatureType === 'typed' || annotation.signatureType === 'initials')) {
                                 if (scaledHeight <= 0) scaledHeight = 60 / scale; // Default height
                                const props = annotation.properties;
                                const colorMapLocal = { black: '#000000', red: '#FF0000', blue: '#0000FF', green: '#008000', purple: '#800080' };
                                const color = props?.color || 'black';
                                const fontFamily = props?.font || 'Arial'; // Fallback font
                                const fontSize = scaledFontSize * (annotation.signatureType === 'initials' ? 1.5 : 1); // Slightly larger initials? Adjusted scale here instead

                                tempCtx.font = `${fontSize}px ${fontFamily}`;
                                tempCtx.fillStyle = colorMapLocal[color] || '#000000';
                                tempCtx.textAlign = 'center';
                                tempCtx.textBaseline = 'middle';

                                // Draw text centered within the annotation bounds
                                tempCtx.fillText(annotation.content, scaledX + scaledWidth / 2, scaledY + scaledHeight / 2);
                            }

                         } catch (drawError) {
                             console.error(`Error drawing annotation ${annotation.id} on page ${i}:`, drawError);
                             // Optionally skip this annotation or log failure
                         } finally {
                             tempCtx.restore(); // Restore context state after drawing each annotation
                         }
                     } // End loop through annotations for the page


                    // Add the completed page (canvas content) to the PDF
                    const imgData = tempCanvas.toDataURL('image/png'); // Use PNG for better quality of text/lines

                    if (i > 1) {
                        doc.addPage([viewport.width, viewport.height], 'portrait');
                    }
                    // Add image stretched to full page size
                    doc.addImage(imgData, 'PNG', 0, 0, viewport.width, viewport.height, undefined, 'FAST'); // Use FAST compression
                    console.log(` Page ${i} added to jsPDF doc.`);

                } // End page loop

                console.log('Saving PDF...');
                doc.save(newFilename);
                console.log('PDF save initiated.');

            } catch (error) {
                console.error('Error during PDF saving process:', error);
                alert('An error occurred while saving the PDF. Please check the console for details.');
            } finally {
                // Restore save button state
                saveBtn.innerHTML = originalIcon;
                saveBtn.disabled = false;
                console.log('Save process finished.');
            }
        }


        // Make functions globally accessible for inline event handlers (like color pickers)
        window.setSignatureColor = setSignatureColor;
        window.setTypedSignatureColor = setTypedSignatureColor;
        // Note: deleteAnnotation is now called via event listener setup in redraw/create, no longer needs global scope

    </script>
</body>
</html>